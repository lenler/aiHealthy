# 项目初始化
项目启动方法:
前提: 具备nodejs环境 推荐版本为22版
1. 安装依赖 在当前项目文件夹的目录下执行npm i
2. 启动项目 在项目文件夹的目录下执行npm run dev
## 项目路由配置
项目使用的vite脚手架开发的React 应用,使用React-routerV7,因为是一个简单的前台应用 暂时没有对应的后台应用 所以不需要动态路由 路由结构是静态的
并且这样做项目的路由配置和维护就会很简单 符合现代开规范
## 项目组件库配置
经过我深思熟虑 还是不要使用国外的组件库了 一个比一个难用 可能是我段位太低了 所以我还是使用arco-design组件库 来自字节跳动的组件库 这个组件库的使用文档比较完善 也有比较多的示例 所以我还是选择使用这个组件库
# 项目结构与功能
1. 先做web端的简单应用 后续拓展成移动端引用
2. 先搭建静态页面 然后根据需求编写业务
3. 前端业务功能
    1. 聊天功能,并且可以让ai根据用户输入的数据 增加删除修改数据展示页面的数据
    2. 分析功能 实现文件上传功能 让ai分析上传的文件 返回对应的数据 然后前端将对应数据渲染到分析界面 前端处理后端发送的sse数据流
    3. 个人中心功能 实现用户信息的展示和修改 利用表单和模态框来实现用户设置 个人信息修改
    4. 用户注册登录 实现用户注册和登录 使用jwt的方式验证 将token存储在redux并对localStorage做持久化操作
    5. 后续业务能力实现
        1. 用户喜好记忆功能 使用心跳机制 定时发送用户输入的数据 并根据用户输入的数据 调整ai的回答
        2. 首页实时推荐功能 利用用户喜好记忆功能 实时推荐用户可能感兴趣的内容
4. node附属层业务
    1. 实现用户登录注册功能 利用node的express框架 实现用户登录注册功能 并将用户信息存储到数据库中
    2. 实现文件上传功能 利用node的express框架 实现文件上传功能 并将文件存储到服务器中
    3. 实现ai分析 使用node层对前端传回的消息进行处理 然后调用ai模型 对消息进行分析 最后将分析结果通过sse发送到前端
    4. ai聊天 node层处理ai服务器发送的流式数据 并将数据通过sse发送到前端
页面布局:
登录注册
首页_>
    导航栏
    侧边栏
    内容区域
        聊天界面
        食品分析界面
        个人中心
        信息设置 提醒设置 喜好设置
# 登录/注册页面的开发
完成静态页面编写后 自己编写mock数据用来模拟后端接口 然后编写http请求 本项目请求主要使用axios库 来发送http请求 并处理响应数据
将不同请求都封装成函数 方便后续调用 并处理响应数据
## 登录页面开发流程
1. 用户填写完登录信息,前端向后端发送登录请求 接受响应结果 
   1. 如果登录成功 前端将token存储到Redux中并且持久化 后续请求在请求头中设置token 为后续个性化服务提供便利
   2. 成功登录 弹出登录成功提示 并跳转首页
2. 在首页做路由守卫 如果检测不到token就跳转到登录页面
注意写完mock要在主页面中引入mock,因为本项目不是团队开发也不是大型项目 所以状态管理使用的是zustand

## zustand使用方法
1. 安装zustand
2. 创建一个store 用来存储状态
3. 在组件中使用useStore 来获取状态和更新状态
创建仓库
```js
import { create } from 'zustand';

// 1. 创建状态仓库：包含「状态」和「修改状态的方法」
const useUserStore = create((set) => ({
  // ---- 定义全局状态 ----
  token: '',        // 用户 Token
  username: '',     // 用户名
  isLogin: false,   // 是否登录

  // ---- 定义修改状态的方法 ----
  // 登录：更新状态 + 存储 Token 到本地
  login: (token, username) => {
    localStorage.setItem('token', token); // 存到本地，实现免登
    // set 方法用于更新状态（类似 React 的 setState）
    set({ token, username, isLogin: true });
  },

  // 退出登录：清空状态 + 清除本地 Token
  logout: () => {
    localStorage.removeItem('token');
    set({ token: '', username: '', isLogin: false });
  },

  // 初始化：页面加载时从本地读取 Token，恢复登录状态
  initUser: () => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username') || '';
    if (token) {
      set({ token, username, isLogin: true });
    }
  }
}));

export default useUserStore;
```
从仓库中获取状态和更新状态
```js
// src/pages/Login.jsx
import React, { useState } from 'react';
import useUserStore from '../store/userStore';

const Login = () => {
  const [inputName, setInputName] = useState('');
  // 从仓库中取出 login 方法（仅取需要的方法，性能更好）
  const login = useUserStore(state => state.login);

  // 模拟登录按钮点击
  const handleLogin = () => {
    if (!inputName) return alert('请输入用户名');
    // 调用仓库的 login 方法，更新全局状态
    login('mock-token-123456', inputName);
    alert('登录成功！');
  };

  return (
    <div style={{ padding: 20 }}>
      <input
        placeholder="请输入用户名"
        value={inputName}
        onChange={(e) => setInputName(e.target.value)}
        style={{ marginBottom: 10, padding: 8 }}
      />
      <button onClick={handleLogin} style={{ padding: 8, cursor: 'pointer' }}>
        登录
      </button>
    </div>
  );
};

export default Login;
```

```js
// src/pages/Home.jsx
import React from 'react';
import useUserStore from '../store/userStore';

const Home = () => {
  // 方式 1：批量读取多个状态（推荐，减少重渲染）
  const { isLogin, username, logout } = useUserStore(state => ({
    isLogin: state.isLogin,
    username: state.username,
    logout: state.logout
  }));

  if (!isLogin) {
    return <div>请先 <a href="/login">登录</a></div>;
  }

  return (
    <div style={{ padding: 20 }}>
      <h3>欢迎你，{username}！</h3>
      <button onClick={logout} style={{ padding: 8, cursor: 'pointer' }}>
        退出登录
      </button>
    </div>
  );
};

export default Home;
```
## token持久化
业务逻辑流程
1. 应用启动 → 从localStorage读取token等认证信息
2. 用户登录 → 设置登录状态并保存到localStorage
3. 用户操作 → 状态变更自动持久化
4. 页面刷新 → 从localStorage恢复状态，保持登录状态
5. 用户登出 → 清除localStorage中的认证信息
   
问题: 在对token进行简单的持久化处理后 在首页我将token删除 不会自动跳转到登录页面 需要刷新后才会实现
实现持久化自动监听token 页面刷新时检查token是否存在 如果不存在则跳转到登录页

# 将原型图迁移到了Ai-Healthy项目中
下一步开始编写进入首页后的业务逻辑
首页业务逻辑分析:
  包含信息:
    1. 数据展示: 用户名 日期 用户头像 用户今日可摄入热量 以及各个数据的展示
    2. 导航栏: 包含咨询 分析 我的 三个选项 点击后跳转到对应的页面
      2.1 咨询: 点击后跳转到ai聊天页面
      2.2 分析: 点击后跳转到分析页面 用于上传食物图片 并收集为json 发送给后端 后端交由ai分析 分析后后端转回结果 前端将收集到的结果放置在首页
      2.3 我的: 点击后跳转到我的页面  
        2.3.1 提醒设置: 点击后跳转到提醒设置页面 用于设置提醒时间 以及是否开启提醒
        2.3.2 账号管理: 点击后跳转到账号管理页面 用于修改密码 以及删除账号
后续打算 将原型图逐步替换为antd组件 尽量保持样式不改变
# 开发首屏数据展示
开发思路就是先设计一套遵循restfulapi的mock模拟数据 然后根据这套数据设置api接口 最后在首页中调用api接口获取数据 展示在首页中
## mock接口设计与api接口设计
mock接口这里不做展示
通过封装api接口
```ts
export function getOverview(){
    return get('/dashboard')
}

export function createRecord(data:any){
    return post('/records',data)
}

// 更新今日指定餐次数据
export function updateRecord(type:string,data:any){
    return put(`/records/${type}`,data)
}

```
## 首页数据获取方法
使用useEffect处理数据获取函数 通过loading状态判断是否展示loading状态 以及是否展示数据 当数据加载完成之后就重新设置loading状态 展示页面
方法有点糙 但是能用
```tsx
return (
  <div id="page-home" className="page-container active" style={{ padding: '40px 20px 20px',backgroundColor:'#fafefb' }}>
    {loading?<Spin/>:<div> .....组件内容</div>}
  </div>
)
```
使用map方法快速生成进度条组件 ['carbs', 'protein', 'fat'] as const 常量断言语法 解决字符串索引与具体对象属性的类型不匹配问题 将string类型的item转换为具体的对象属性类型
```tsx
<Col xs={24} sm={14} md={16}>
  <div className="macro-stats">
    {
      (['carbs', 'protein', 'fat'] as const).map((item) => {
        const data = summary?.[item];
        return (
          <div key={item} className="macro-item">
            <Row justify="space-between" style={{ marginBottom: '4px' }}>
              <Text>{macroLabels[item]}</Text>
              <Text type="secondary">{data?.current}/{data?.target}{data?.unit}</Text>
            </Row>
            <Progress
              className="macroProgress"
              // 计算百分比 当前摄入量/总摄入量 * 100
              percent={data ? (data.current / data.target) * 100 : 0}
              showInfo={false}
              strokeColor={item === 'carbs' ? '#fbbf24' : item === 'protein' ? '#60a5fa' : '#10b981'}
              trailColor="#e2e8f0"
              size="small"
            />
          </div>
        )
      })
    }
  </div>
</Col>
```
# 开发首页卡片今日饮食记录的新增与修改,删除功能

在今天的开发完成了首页核心功能——“今日饮食记录”卡片的重构与增删改查（CRUD）逻辑的集成。为了提升用户体验，我们将原本分散在页面顶部的全局操作按钮全部移除，转而采用更加直观的“卡片内联操作”模式。

**1. UI 交互逻辑重构与 RecordCard 组件升级**
我们重新设计了 `RecordCard` 组件，使其具备了三种状态：有数据态、无数据态（空白占位）和只读态。在有数据时，卡片右上角会悬浮显示编辑和删除图标，且删除操作接入了 `Popconfirm` 二次确认弹窗以防误删；当某餐次（早餐、午餐、晚餐）暂无记录时，卡片会显示为一个带有加号按钮的占位容器，引导用户点击新增。此外，通过 `readOnly` 属性，我们让“昨日记录”部分复用了同一套卡片样式，但禁用了所有操作权限，保持了界面的统一性与逻辑的严密性。

**2. 样式优化与内联样式提取**
为了解决图片在卡片中显示不全的问题，我们利用 CSS 的 `object-fit: cover` 属性确保了食物图片能够完美填充容器背景。同时，为了提高代码的可维护性，我们将 `DashBoread/index.tsx` 中大量的内联样式提取到了独立的 `index.scss` 文件中，利用 SCSS 的嵌套语法清晰地管理页面布局、圆环统计区以及卡片网格系统。

**3. 表单状态管理与异步数据同步**
在 `RecordForm` 表单组件的开发中，我们解决了 React 常见的“渲染期间更新状态”的警告。通过 `useEffect` 钩子，我们确保了在 Modal 打开时才将选中的记录数据同步到 Ant Design 的 Form 实例中。在数据提交环节，我们打通了从表单校验、调用 `updateRecord` API 到父组件 `refresh` 刷新列表的完整链路。

**4. 技术细节与错误修复**
针对开发过程中遇到的 TypeScript 类型报错，我们通过 `as const` 断言解决了对象索引访问的类型安全问题。同时，针对 Mock 环境下偶尔出现的网络超时错误，我们将 Axios 的基础配置 `timeout` 从 300ms 提高到了 5000ms，确保了请求的稳定性。此外，我们还修正了代码中如 `todayReacord` 等拼写错误，并优化了数据获取函数，将其封装在 `try-catch-finally` 结构中，确保了 Loading 状态能够正确闭环。

目前，首页饮食记录的“增、删、改、查”功能已全部跑通，页面布局清爽且操作逻辑符合直觉，为后续接入 AI 饮食建议功能打下了坚实的 UI 与数据基础。

这一天的开发涵盖了 React 组件设计、TypeScript 类型体操、Ant Design 深度应用以及异步数据流管理。
### 1. 难点与解决方案 (Challenges & Solutions)

*   **React 渲染周期的状态同步 (`setState` in `useEffect`)**
    *   **问题**：在 `RecordForm` 中，直接在组件函数体内部调用 `form.setFieldsValue` 会导致 "Cannot update a component while rendering a different component" 警告，甚至引发无限循环渲染。
    *   **解决**：将表单数据的回填逻辑包裹在 `useEffect` 中，并依赖 `isModalOpen` 和数据源的变化。这确保了状态更新只在副作用阶段（Render 之后）发生，符合 React 的单向数据流原则。



*   **TypeScript 动态索引签名 (`Index Signature`)**
    *   **问题**：在遍历 `summary` 对象时，使用 `item` (string) 去访问 `summary[item]` 会报错，因为 TypeScript 无法确定字符串变量是否是 `summary` 对象的有效 Key。
    *   **解决**：使用 **Const Assertion** (`as const`)。
    *   **代码**：
        ```typescript
        {/* 之前是 string[]，现在通过 as const 锁定为字面量元组 */}
        {['carbs', 'protein', 'fat'] as const).map(item => (
            // summary[item] 现在是类型安全的
        ))}
        ```
    *   后续我们将这种方式直接封装成数组变量和获取对应数据的辅助函数 来统一处理 让数据更易读,这不仅解决了报错，还为 IDE 提供了更好的自动补全支持。

### 2. 技术重点 (Key Technical Points)

*   **组件的职责分离与复用 (`RecordCard` Design)**
    *   我们设计了一个高度复用的 [recordCard.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/components/dashborad/recordCard.tsx)，它不仅仅是一个展示组件，还通过 `readOnly` 属性和传入的回调函数（`onEdit`, `onDelete`）承载了业务逻辑的入口。
    *   **Empty State Pattern**：在组件内部处理“无数据”状态，显示占位符和新增按钮，而不是在父组件写 `if-else`，这大大简化了父组件 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx) 的 JSX 结构。

### 3. 经验

*   **异步操作的完整闭环 (`Try-Catch-Finally`)**
    *   在 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx#L96-102) 的 `getOverviewData` 中，我们将 `setLoading(false)` 放在 `finally` 块中。这保证了无论请求成功还是失败（甚至是代码报错），Loading 状态都能被正确重置，避免页面“假死”。

# 后续优化方向
在修改完卡片数据后 做到只刷新对应卡片的数据 而不是刷新整个页面