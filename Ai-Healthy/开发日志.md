# 项目初始化
项目启动方法:
前提: 具备nodejs环境 推荐版本为22版
1. 安装依赖 在当前项目文件夹的目录下执行npm i
2. 启动项目 在项目文件夹的目录下执行npm run dev
## 项目路由配置
项目使用的vite脚手架开发的React 应用,使用React-routerV7,因为是一个简单的前台应用 暂时没有对应的后台应用 所以不需要动态路由 路由结构是静态的
并且这样做项目的路由配置和维护就会很简单 符合现代开规范
## 项目组件库配置
经过我深思熟虑 还是不要使用国外的组件库了 一个比一个难用 可能是我段位太低了 所以我还是使用arco-design组件库 来自字节跳动的组件库 这个组件库的使用文档比较完善 也有比较多的示例 所以我还是选择使用这个组件库
# 项目结构与功能
1. 先做web端的简单应用 后续拓展成移动端引用
2. 先搭建静态页面 然后根据需求编写业务
3. 前端业务功能
    1. 聊天功能,并且可以让ai根据用户输入的数据 增加删除修改数据展示页面的数据
    2. 分析功能 实现文件上传功能 让ai分析上传的文件 返回对应的数据 然后前端将对应数据渲染到分析界面 前端处理后端发送的sse数据流
    3. 个人中心功能 实现用户信息的展示和修改 利用表单和模态框来实现用户设置 个人信息修改
    4. 用户注册登录 实现用户注册和登录 使用jwt的方式验证 将token存储在redux并对localStorage做持久化操作
    5. 后续业务能力实现
        1. 用户喜好记忆功能 使用心跳机制 定时发送用户输入的数据 并根据用户输入的数据 调整ai的回答
        2. 首页实时推荐功能 利用用户喜好记忆功能 实时推荐用户可能感兴趣的内容
4. node附属层业务
    1. 实现用户登录注册功能 利用node的express框架 实现用户登录注册功能 并将用户信息存储到数据库中
    2. 实现文件上传功能 利用node的express框架 实现文件上传功能 并将文件存储到服务器中
    3. 实现ai分析 使用node层对前端传回的消息进行处理 然后调用ai模型 对消息进行分析 最后将分析结果通过sse发送到前端
    4. ai聊天 node层处理ai服务器发送的流式数据 并将数据通过sse发送到前端
页面布局:
登录注册
首页_>
    导航栏
    侧边栏
    内容区域
        聊天界面
        食品分析界面
        个人中心
        信息设置 提醒设置 喜好设置
# 登录/注册页面的开发
完成静态页面编写后 自己编写mock数据用来模拟后端接口 然后编写http请求 本项目请求主要使用axios库 来发送http请求 并处理响应数据
将不同请求都封装成函数 方便后续调用 并处理响应数据
## 登录页面开发流程
1. 用户填写完登录信息,前端向后端发送登录请求 接受响应结果 
   1. 如果登录成功 前端将token存储到Redux中并且持久化 后续请求在请求头中设置token 为后续个性化服务提供便利
   2. 成功登录 弹出登录成功提示 并跳转首页
2. 在首页做路由守卫 如果检测不到token就跳转到登录页面
注意写完mock要在主页面中引入mock,因为本项目不是团队开发也不是大型项目 所以状态管理使用的是zustand

## zustand使用方法
1. 安装zustand
2. 创建一个store 用来存储状态
3. 在组件中使用useStore 来获取状态和更新状态
创建仓库
```js
import { create } from 'zustand';

// 1. 创建状态仓库：包含「状态」和「修改状态的方法」
const useUserStore = create((set) => ({
  // ---- 定义全局状态 ----
  token: '',        // 用户 Token
  username: '',     // 用户名
  isLogin: false,   // 是否登录

  // ---- 定义修改状态的方法 ----
  // 登录：更新状态 + 存储 Token 到本地
  login: (token, username) => {
    localStorage.setItem('token', token); // 存到本地，实现免登
    // set 方法用于更新状态（类似 React 的 setState）
    set({ token, username, isLogin: true });
  },

  // 退出登录：清空状态 + 清除本地 Token
  logout: () => {
    localStorage.removeItem('token');
    set({ token: '', username: '', isLogin: false });
  },

  // 初始化：页面加载时从本地读取 Token，恢复登录状态
  initUser: () => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username') || '';
    if (token) {
      set({ token, username, isLogin: true });
    }
  }
}));

export default useUserStore;
```
从仓库中获取状态和更新状态
```js
// src/pages/Login.jsx
import React, { useState } from 'react';
import useUserStore from '../store/userStore';

const Login = () => {
  const [inputName, setInputName] = useState('');
  // 从仓库中取出 login 方法（仅取需要的方法，性能更好）
  const login = useUserStore(state => state.login);

  // 模拟登录按钮点击
  const handleLogin = () => {
    if (!inputName) return alert('请输入用户名');
    // 调用仓库的 login 方法，更新全局状态
    login('mock-token-123456', inputName);
    alert('登录成功！');
  };

  return (
    <div style={{ padding: 20 }}>
      <input
        placeholder="请输入用户名"
        value={inputName}
        onChange={(e) => setInputName(e.target.value)}
        style={{ marginBottom: 10, padding: 8 }}
      />
      <button onClick={handleLogin} style={{ padding: 8, cursor: 'pointer' }}>
        登录
      </button>
    </div>
  );
};

export default Login;
```

```js
// src/pages/Home.jsx
import React from 'react';
import useUserStore from '../store/userStore';

const Home = () => {
  // 方式 1：批量读取多个状态（推荐，减少重渲染）
  const { isLogin, username, logout } = useUserStore(state => ({
    isLogin: state.isLogin,
    username: state.username,
    logout: state.logout
  }));

  if (!isLogin) {
    return <div>请先 <a href="/login">登录</a></div>;
  }

  return (
    <div style={{ padding: 20 }}>
      <h3>欢迎你，{username}！</h3>
      <button onClick={logout} style={{ padding: 8, cursor: 'pointer' }}>
        退出登录
      </button>
    </div>
  );
};

export default Home;
```
## token持久化
业务逻辑流程
1. 应用启动 → 从localStorage读取token等认证信息
2. 用户登录 → 设置登录状态并保存到localStorage
3. 用户操作 → 状态变更自动持久化
4. 页面刷新 → 从localStorage恢复状态，保持登录状态
5. 用户登出 → 清除localStorage中的认证信息
   
问题: 在对token进行简单的持久化处理后 在首页我将token删除 不会自动跳转到登录页面 需要刷新后才会实现
实现持久化自动监听token 页面刷新时检查token是否存在 如果不存在则跳转到登录页

# 将原型图迁移到了Ai-Healthy项目中
下一步开始编写进入首页后的业务逻辑
首页业务逻辑分析:
  包含信息:
    1. 数据展示: 用户名 日期 用户头像 用户今日可摄入热量 以及各个数据的展示
    2. 导航栏: 包含咨询 分析 我的 三个选项 点击后跳转到对应的页面
      2.1 咨询: 点击后跳转到ai聊天页面
      2.2 分析: 点击后跳转到分析页面 用于上传食物图片 并收集为json 发送给后端 后端交由ai分析 分析后后端转回结果 前端将收集到的结果放置在首页
      2.3 我的: 点击后跳转到我的页面  
        2.3.1 提醒设置: 点击后跳转到提醒设置页面 用于设置提醒时间 以及是否开启提醒
        2.3.2 账号管理: 点击后跳转到账号管理页面 用于修改密码 以及删除账号
后续打算 将原型图逐步替换为antd组件 尽量保持样式不改变
# 开发首屏数据展示
开发思路就是先设计一套遵循restfulapi的mock模拟数据 然后根据这套数据设置api接口 最后在首页中调用api接口获取数据 展示在首页中
## mock接口设计与api接口设计
mock接口这里不做展示
通过封装api接口
```ts
export function getOverview(){
    return get('/dashboard')
}

export function createRecord(data:any){
    return post('/records',data)
}

// 更新今日指定餐次数据
export function updateRecord(type:string,data:any){
    return put(`/records/${type}`,data)
}

```
## 首页数据获取方法
使用useEffect处理数据获取函数 通过loading状态判断是否展示loading状态 以及是否展示数据 当数据加载完成之后就重新设置loading状态 展示页面
方法有点糙 但是能用
```tsx
return (
  <div id="page-home" className="page-container active" style={{ padding: '40px 20px 20px',backgroundColor:'#fafefb' }}>
    {loading?<Spin/>:<div> .....组件内容</div>}
  </div>
)
```
使用map方法快速生成进度条组件 ['carbs', 'protein', 'fat'] as const 常量断言语法 解决字符串索引与具体对象属性的类型不匹配问题 将string类型的item转换为具体的对象属性类型
```tsx
<Col xs={24} sm={14} md={16}>
  <div className="macro-stats">
    {
      (['carbs', 'protein', 'fat'] as const).map((item) => {
        const data = summary?.[item];
        return (
          <div key={item} className="macro-item">
            <Row justify="space-between" style={{ marginBottom: '4px' }}>
              <Text>{macroLabels[item]}</Text>
              <Text type="secondary">{data?.current}/{data?.target}{data?.unit}</Text>
            </Row>
            <Progress
              className="macroProgress"
              // 计算百分比 当前摄入量/总摄入量 * 100
              percent={data ? (data.current / data.target) * 100 : 0}
              showInfo={false}
              strokeColor={item === 'carbs' ? '#fbbf24' : item === 'protein' ? '#60a5fa' : '#10b981'}
              trailColor="#e2e8f0"
              size="small"
            />
          </div>
        )
      })
    }
  </div>
</Col>
```
# 开发首页卡片今日饮食记录的新增与修改,删除功能

在今天的开发完成了首页核心功能——“今日饮食记录”卡片的重构与增删改查（CRUD）逻辑的集成。为了提升用户体验，我们将原本分散在页面顶部的全局操作按钮全部移除，转而采用更加直观的“卡片内联操作”模式。

**1. UI 交互逻辑重构与 RecordCard 组件升级**
我们重新设计了 `RecordCard` 组件，使其具备了三种状态：有数据态、无数据态（空白占位）和只读态。在有数据时，卡片右上角会悬浮显示编辑和删除图标，且删除操作接入了 `Popconfirm` 二次确认弹窗以防误删；当某餐次（早餐、午餐、晚餐）暂无记录时，卡片会显示为一个带有加号按钮的占位容器，引导用户点击新增。此外，通过 `readOnly` 属性，我们让“昨日记录”部分复用了同一套卡片样式，但禁用了所有操作权限，保持了界面的统一性与逻辑的严密性。

**2. 样式优化与内联样式提取**
为了解决图片在卡片中显示不全的问题，我们利用 CSS 的 `object-fit: cover` 属性确保了食物图片能够完美填充容器背景。同时，为了提高代码的可维护性，我们将 `DashBoread/index.tsx` 中大量的内联样式提取到了独立的 `index.scss` 文件中，利用 SCSS 的嵌套语法清晰地管理页面布局、圆环统计区以及卡片网格系统。

**3. 表单状态管理与异步数据同步**
在 `RecordForm` 表单组件的开发中，我们解决了 React 常见的“渲染期间更新状态”的警告。通过 `useEffect` 钩子，我们确保了在 Modal 打开时才将选中的记录数据同步到 Ant Design 的 Form 实例中。在数据提交环节，我们打通了从表单校验、调用 `updateRecord` API 到父组件 `refresh` 刷新列表的完整链路。

**4. 技术细节与错误修复**
针对开发过程中遇到的 TypeScript 类型报错，我们通过 `as const` 断言解决了对象索引访问的类型安全问题。同时，针对 Mock 环境下偶尔出现的网络超时错误，我们将 Axios 的基础配置 `timeout` 从 300ms 提高到了 5000ms，确保了请求的稳定性。此外，我们还修正了代码中如 `todayReacord` 等拼写错误，并优化了数据获取函数，将其封装在 `try-catch-finally` 结构中，确保了 Loading 状态能够正确闭环。
目前，首页饮食记录的“增、删、改、查”功能已全部跑通，页面布局清爽且操作逻辑符合直觉，为后续接入 AI 饮食建议功能打下了坚实的 UI 与数据基础。
这一天的开发涵盖了 React 组件设计、TypeScript 类型体操、Ant Design 深度应用以及异步数据流管理。
### 1. 难点与解决方案 (Challenges & Solutions)
*   **React 渲染周期的状态同步 (`setState` in `useEffect`)**
    *   **问题**：在 `RecordForm` 中，直接在组件函数体内部调用 `form.setFieldsValue` 会导致 "Cannot update a component while rendering a different component" 警告，甚至引发无限循环渲染。
    *   **解决**：将表单数据的回填逻辑包裹在 `useEffect` 中，并依赖 `isModalOpen` 和数据源的变化。这确保了状态更新只在副作用阶段（Render 之后）发生，符合 React 的单向数据流原则。
*   **TypeScript 动态索引签名 (`Index Signature`)**
    *   **问题**：在遍历 `summary` 对象时，使用 `item` (string) 去访问 `summary[item]` 会报错，因为 TypeScript 无法确定字符串变量是否是 `summary` 对象的有效 Key。
    *   **解决**：使用 **Const Assertion** (`as const`)。
    *   **代码**：
        ```typescript
        {/* 之前是 string[]，现在通过 as const 锁定为字面量元组 */}
        {['carbs', 'protein', 'fat'] as const).map(item => (
            // summary[item] 现在是类型安全的
        ))}
        ```
    *   后续我们将这种方式直接封装成数组变量和获取对应数据的辅助函数 来统一处理 让数据更易读,这不仅解决了报错，还为 IDE 提供了更好的自动补全支持。
### 2. 技术重点 (Key Technical Points)
*   **组件的职责分离与复用 (`RecordCard` Design)**
    *   我们设计了一个高度复用的 [recordCard.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/components/dashborad/recordCard.tsx)，它不仅仅是一个展示组件，还通过 `readOnly` 属性和传入的回调函数（`onEdit`, `onDelete`）承载了业务逻辑的入口。
    *   **Empty State Pattern**：在组件内部处理“无数据”状态，显示占位符和新增按钮，而不是在父组件写 `if-else`，这大大简化了父组件 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx) 的 JSX 结构。
### 3. 经验
*   **异步操作的完整闭环 (`Try-Catch-Finally`)**
    *   在 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx#L96-102) 的 `getOverviewData` 中，我们将 `setLoading(false)` 放在 `finally` 块中。这保证了无论请求成功还是失败（甚至是代码报错），Loading 状态都能被正确重置，避免页面“假死”。

# 后续优化方向
在修改完卡片数据后 做到只刷新对应卡片的数据 而不是刷新整个页面

# 接入ai 
## 简单搭建后端服务 
这个服务是异步处理的 本质上是在ai服务供应商的服务器上处理请求 将请求信息转发到前端 也就是一个BWF信息转发层
1. node服务 主要的点是使用openai的api实现与ai服务器的通信 然后将接口转发到前端  openai.chat.completions.create
2.  openai.chat.completions.create函数包含一个对象参数 对象参数中需要两个属性
    * messages: [{ role: "user", content: message }], 包含用户输入的信息
    * model: "deepseek-chat"  使用的模型
```js
import express from 'express'
const app=express()
import OpenAI from "openai";
import cors from 'cors' 

app.use(cors())
app.use(express.json())

const openai = new OpenAI({
        baseURL: 'https://api.deepseek.com',
        apiKey: 'sk-1ab0732077a749b2962dcc8cc1dca7e9',
});
app.post('/api/chat',async (req,res)=>{
    try {
        const {message}=req.body
        console.log('收到消息:', message); // Debug log
        const completion = await openai.chat.completions.create({
            messages: [{ role: "user", content: message }],
            model: "deepseek-chat",
        });
        
        console.log('AI响应:', completion.choices[0].message.content);
        res.json({response:completion.choices[0].message.content})
    } catch (error) {
        console.error('服务器错误详细信息:', error); // 打印完整错误堆栈
        res.status(500).json({ 
            error: '服务器内部错误', 
            details: error.message 
        });
    }
})
app.listen(3000,()=>{
    console.log('server is running on port 3000')
})

```
completion用来接受ai服务器发送回来的响应内容 
```js
const completion = await openai.chat.completions.create({
  messages: [{ role: "user", content: message }],
  model: "deepseek-chat",
});
```
## 搭建简答的前端服务
搭建相当简单 只需要对信息做收集 发送 接受 渲染即可
```html
<body>
    <input type="text" id="message-input" placeholder="请输入消息">
    <button id="send-button">发送</button>
    <div id="chat-container"></div>
</body>
<script>
    const messageInput=document.getElementById('message-input')
    const sendButton=document.getElementById('send-button')
    const chatContainer=document.getElementById('chat-container')
    async function sendMessage(message){
        const response=await fetch('http://localhost:3000/api/chat',{
            method:'POST',
            headers:{
                'Content-Type':'application/json'
            },
            body:JSON.stringify({message})
        })
        const data=await response.json()
        return data.response
    }
    sendButton.addEventListener('click',async ()=>{
        const message=messageInput.value
        if(!message) return
        messageInput.value=''
        const userMessage=document.createElement('div')
        userMessage.textContent=`你:${message}`
        chatContainer.appendChild(userMessage)
        const botMessage=document.createElement('div')
        botMessage.textContent=`助手:${await sendMessage(message)}`
        chatContainer.appendChild(botMessage)
    })
```

## 改造node服务 请求流式响应 发送流式响应 前端渲染流式响应 实现打字机效果
### 1. 后端请求流式响应 并转发
开是要设置响应头: 这是必须要设置的 告诉前端这是一个流式响应 不能缓存 保持连接
```js
res.setHeader('Content-Type','text/event-stream')//流式输出
    res.setHeader('Cache-Control','no-cache')// 禁用缓存
    res.setHeader('Connection','keep-alive')// 保持连接
```
然后模拟ai服务 逐字返回 前端渲染打字机效果:
这里我们必须要注意 每次发送字符给前端 都必须要符合SSE协议格式 否则前端无法正确解析 也就是每次都发送`data: ${JSON.stringify({ content: char })}\n\n` 这是固定写法 而且必须使用res.write 发送 不能使用res.send 否则前端无法正确解析
在响应的最后必须发送`data: [DONE]\n\n` 这是固定写法 否则前端无法正确解析
```js
// 模拟ai逐字逐字返回
let index=0
const timer = setInterval(() => {
if (index < Answer.length) {
  //SSE 协议格式：data: 内容\n\n（必须严格遵守）
  const char = Answer[index];
  // 核心 使用res.write 发送字符给前端
  res.write(`data: ${JSON.stringify({ content: char })}\n\n`);
  index++;
} else {
  // 结束流式传输（发送结束标识）
  clearInterval(timer);
  res.write('data: [DONE]\n\n'); // 自定义结束标识
  res.end(); // 关闭连接
}
}, 100); // 每 100ms 返回一个字符，模拟打字机速度
```
因为我们在响应头设置了保持链接的响应头 所以必须主动去断开链接
```js
// 5. 处理前端断开连接（避免内存泄漏）
res.on('close', () => {
  clearInterval(timer);
  res.end();
});
```
完整代码
```js
sseApp.post('/api/chat',async (req,res)=>{
    // 设置响应头 发送sse 流
    res.setHeader('Content-Type','text/event-stream')//流式输出
    res.setHeader('Cache-Control','no-cache')// 禁用缓存
    res.setHeader('Connection','keep-alive')// 保持连接
    // 从前端获取消息
    const {message}=req.body
    // 发送消息给前端
    const Answer='这是你发送的消息:'+message+'这段消息用来处理学习sse数据的实现一个极简的 Demo：前端输入文字 → 后端模拟 AI 逐字返回（打字机效果）→ 前端实时展示，不涉及 AI 真实接口，只聚焦 SSE 流式处理本身'
    // 模拟ai逐字逐字返回
    let index=0
    const timer = setInterval(() => {
    if (index < Answer.length) {
      //SSE 协议格式：data: 内容\n\n（必须严格遵守）
      const char = Answer[index];
      // 核心 使用res.write 发送字符给前端
      res.write(`data: ${JSON.stringify({ content: char })}\n\n`);
      index++;
    } else {
      // 结束流式传输（发送结束标识）
      clearInterval(timer);
      res.write('data: [DONE]\n\n'); // 自定义结束标识
      res.end(); // 关闭连接
    }
  }, 100); // 每 100ms 返回一个字符，模拟打字机速度

  // 5. 处理前端断开连接（避免内存泄漏）
  res.on('close', () => {
    clearInterval(timer);
    res.end();
  });
})
```
### 2. 前端渲染流式响应 实现打字机效果
1. 发送请求
在发送请求是必须带上响应头: 否则前端不能解析后端传来的数据
```js
'Content-Type':'application/json'
```
2. 处理后端数据 实现打字机效果
  1. 首先使用`response.body.getReader()` 方法获取到一个`ReadableStreamDefaultReader` 对象 这个对象可以用来读取流式响应的数据 就是创建一个读取器 这个读取器允许我们手动、逐块读取流式响应中的数据
   ```js
    const reader = response.body.getReader();
   ```
  2. 创建一个解码器 用来将获取的二进制字符转换为字符数据 这里我们使用`TextDecoder` 这个类 来创建一个解码器 这个解码器可以将二进制数据转换为字符串 注意因为流式处理每次只能传递一个字符 我们需要使用循环来读取所有字符
   ```js
    const decoder = new TextDecoder(); 
     while (true) {
      //....
  }
   ```
  3. 使用读取器中的read方法 将获取的数据逐块读取 并使用解码器将二进制数据转换为字符串 value是二进制数据表示当前读取的字符 done表示是否读取完成
   ```js
    const { done, value } = await reader.read();
    console.log('done:',done);   // 布尔值
    console.log('value:',value); //二进制数据
    if (done) break;
   ```
  4. 使用解码器将获取的value数据转化为字符串  chunk:" data: {"content":"身"}\n\n '空' " 这是我们转化得到的数据 使用\n\n来分割分割后的数据 lines:['data: {"content":"身"}', '']是一个数组
   ```js
    const chunk = decoder.decode(value); // 解析后是一个字符串 " data: {"content":"身"}\n\n '空' "
    console.log('chunk:',chunk);
    // SSE 数据可能一次包含多个消息，按 \n\n 分割
    const lines = chunk.split('\n\n');
    console.log('lines:',lines);// 分割后是一个数组 ['data: {"content":"身"}\n\n', '']
    ```
  5. 遍历lines数组 对每个元素进行处理 去掉前缀'data: '和分割后多余的空字符串'' 得到最终的数据 {"content":"身"}  注意w3c规范流式输出结束后需要传递[data: [DONE]] 我们需要判断是否是结束标识 如果是结束标识 则直接跳出循环 否则继续处理
  6. 将得到的数据转化为json数据  const json = JSON.parse(dataStr);  aiAnswer.textContent += json.content;最后渲染到前端
  ```js
  for (const line of lines) {
          if (line.startsWith('data: ')) {
              const dataStr = line.replace('data: ', '').trim(); // 去掉前缀 'data: '和分割后多余的空字符串''
              console.log('dataStr:',dataStr); // {"content":"身"} 得到的数据
              if (dataStr === '[DONE]') { //根据协议标准 到响应的最后阶段会传递结束符 chunk: data: [DONE]
                  console.log('流传输结束');
                  break;
              }
              try {
                  // 必带：解析 JSON 字符串 原本 {"content":"身"}--> {content:'身'}
                  const json = JSON.parse(dataStr); 
                  console.log('json:',json);
                  // 实时追加内容
                  aiAnswer.textContent += json.content;
              } catch (e) {
                  console.error('解析 JSON 失败:', e, dataStr);
              }
          }
      }
  ```
完整代码
```js
sendBtn.addEventListener('click',async ()=>{
  const message=inputMsg.value
  if(!message) return
  inputMsg.value=''
  aiAnswer.textContent='' // 清空之前的回答        
  const response=await fetch('http://localhost:3000/api/chat',{
      method:'POST',
      headers:{
          // 必带：告诉后端请求体是 JSON 格式（否则后端 req.body 为 undefined）
          'Content-Type':'application/json'
      },
      body:JSON.stringify({message})
  })

  // 核心：处理流式响应
  const reader = response.body.getReader();
  console.log('reader:',reader);
  // 必带：创建文本解码器，将二进制数据转换为字符串
  const decoder = new TextDecoder(); 
  while (true) {
      console.log('读取数据');
      // done: 表示流是否结束 value: 表示读取到的二进制数据
      const { done, value } = await reader.read();
      console.log('done:',done);   // 布尔值
      console.log('value:',value); //二进制数据
      if (done) break;
      // 解码二进制数据
      const chunk = decoder.decode(value); // 解析后是一个字符串 " data: {"content":"身"}\n\n '空' "
      console.log('chunk:',chunk);
      // SSE 数据可能一次包含多个消息，按 \n\n 分割
      const lines = chunk.split('\n\n');
      console.log('lines:',lines);// 分割后是一个数组 ['data: {"content":"身"}\n\n', '']
      
      for (const line of lines) {
          if (line.startsWith('data: ')) {
              const dataStr = line.replace('data: ', '').trim(); // 去掉前缀 'data: '和分割后多余的空字符串''
              console.log('dataStr:',dataStr); // {"content":"身"} 得到的数据
              if (dataStr === '[DONE]') { //根据协议标准 到响应的最后阶段会传递结束符 chunk: data: [DONE]
                  console.log('流传输结束');
                  break;
              }
              try {
                  // 必带：解析 JSON 字符串 原本 {"content":"身"}--> {content:'身'}
                  const json = JSON.parse(dataStr); 
                  console.log('json:',json);
                  // 实时追加内容
                  aiAnswer.textContent += json.content;
              } catch (e) {
                  console.error('解析 JSON 失败:', e, dataStr);
              }
          }
      }
  }
})
```
### 使用真实api接口处理流式响应
前端部分不变 只需要修改后内容
基本上内容大差不差 不会变 处理流式响应只需要在openai.chat.completions.create()中添加stream: true, // 开启流式输出
然后使用异步遍历(异步迭代器)的方法将请求来的数据逐块读取 并按SSE协议格式推送给前端
```js
// 设置响应头 发送sse 流
  res.setHeader('Content-Type','text/event-stream')//流式输出
  res.setHeader('Cache-Control','no-cache')// 禁用缓存
  res.setHeader('Connection','keep-alive')// 保持连接
  // 从前端获取消息
  const {message}=req.body
  // 发送消息给前端
  const stream = await openai.chat.completions.create({
    messages: [
      { role: "system", content: "You are a helpful assistant." }, // 系统提示词
      { role: "user", content: message } // 用户提问
    ],
    model: "deepseek-chat",
    stream: true, // 开启流式输出
    temperature: 0.7, // 可选：调整回答随机性
  });

  // 3. 逐块读取流式数据（异步迭代器）
  for await (const chunk of stream) {
    // 3.1 提取单块内容（注意：chunk 可能为空，需过滤）
    const content = chunk.choices[0]?.delta?.content || '';
    if (content) {
      // 3.2 按 SSE 协议格式推送给前端（\n\n 结尾）
      res.write(`data: ${JSON.stringify({ content })}\n\n`);
    }
  }
// 5. 处理前端断开连接（避免内存泄漏）
res.on('close', () => {
  clearInterval(timer);
  res.end();
});
```

# 在项目中接入ai 
我们使用antdx组件库 npm install @ant-design/x --save 来快速开发对应的样式
处理流式数据与ai api工具集 我们使用aiSDK npm install @ant-design/x-sdk --save
## 使用AISDK