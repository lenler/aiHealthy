# 项目初始化
项目启动方法:
前提: 具备nodejs环境 推荐版本为22版
1. 安装依赖 在当前项目文件夹的目录下执行npm i
2. 启动项目 在项目文件夹的目录下执行npm run dev
## 项目路由配置
项目使用的vite脚手架开发的React 应用,使用React-routerV7,因为是一个简单的前台应用 暂时没有对应的后台应用 所以不需要动态路由 路由结构是静态的
并且这样做项目的路由配置和维护就会很简单 符合现代开规范
## 项目组件库配置
经过我深思熟虑 还是不要使用国外的组件库了 一个比一个难用 可能是我段位太低了 所以我还是使用arco-design组件库 来自字节跳动的组件库 这个组件库的使用文档比较完善 也有比较多的示例 所以我还是选择使用这个组件库
# 项目定位与核心功能
- 主定位：健康饮食管理，不以“减肥”作为主叙事
- 核心能力：饮食记录、饮食分析、每日热量管理
# 项目结构与功能
1. 先做web端的简单应用 后续拓展成移动端引用
2. 先搭建静态页面 然后根据需求编写业务
3. 前端业务功能
    1. 聊天功能,并且可以让ai根据用户输入的数据 增加删除修改数据展示页面的数据
    2. 分析功能 实现文件上传功能 让ai分析上传的文件 返回对应的数据 然后前端将对应数据渲染到分析界面 前端处理后端发送的数据
    3. 个人中心功能 实现用户信息的展示和修改 利用表单和模态框来实现用户设置 个人信息修改
    4. 用户注册登录 实现用户注册和登录 使用jwt的方式验证 将token存储在redux并对localStorage做持久化操作
    5. 后续业务能力实现
        1. 用户喜好记忆功能 使用心跳机制 定时发送用户输入的数据 并根据用户输入的数据 调整ai的回答
        2. 首页实时推荐功能 利用用户喜好记忆功能 实时推荐用户可能感兴趣的内容
4. node附属层业务
    1. 实现用户登录注册功能 利用node的express框架 实现用户登录注册功能 并将用户信息存储到数据库中
    2. 实现文件上传功能 利用node的express框架 实现文件上传功能 并将文件存储到服务器中
    3. 实现ai分析 使用node层对前端传回的消息进行处理 然后调用ai模型 对消息进行分析 最后将分析结果通过sse发送到前端
    4. ai聊天 node层处理ai服务器发送的流式数据 并将数据通过sse发送到前端
页面布局:
登录注册
首页_>
    导航栏
    侧边栏
    内容区域
        聊天界面
        食品分析界面
        个人中心
        信息设置 提醒设置 喜好设置
# 登录/注册页面的开发
完成静态页面编写后 自己编写mock数据用来模拟后端接口 然后编写http请求 本项目请求主要使用axios库 来发送http请求 并处理响应数据
将不同请求都封装成函数 方便后续调用 并处理响应数据
## 登录页面开发流程
1. 用户填写完登录信息,前端向后端发送登录请求 接受响应结果 
   1. 如果登录成功 前端将token存储到Redux中并且持久化 后续请求在请求头中设置token 为后续个性化服务提供便利
   2. 成功登录 弹出登录成功提示 并跳转首页
2. 在首页做路由守卫 如果检测不到token就跳转到登录页面
注意写完mock要在主页面中引入mock,因为本项目不是团队开发也不是大型项目 所以状态管理使用的是zustand

## zustand使用方法
1. 安装zustand
2. 创建一个store 用来存储状态
3. 在组件中使用useStore 来获取状态和更新状态
创建仓库
```js
import { create } from 'zustand';

// 1. 创建状态仓库：包含「状态」和「修改状态的方法」
const useUserStore = create((set) => ({
  // ---- 定义全局状态 ----
  token: '',        // 用户 Token
  username: '',     // 用户名
  isLogin: false,   // 是否登录

  // ---- 定义修改状态的方法 ----
  // 登录：更新状态 + 存储 Token 到本地
  login: (token, username) => {
    localStorage.setItem('token', token); // 存到本地，实现免登
    // set 方法用于更新状态（类似 React 的 setState）
    set({ token, username, isLogin: true });
  },

  // 退出登录：清空状态 + 清除本地 Token
  logout: () => {
    localStorage.removeItem('token');
    set({ token: '', username: '', isLogin: false });
  },

  // 初始化：页面加载时从本地读取 Token，恢复登录状态
  initUser: () => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username') || '';
    if (token) {
      set({ token, username, isLogin: true });
    }
  }
}));

export default useUserStore;
```
从仓库中获取状态和更新状态
```js
// src/pages/Login.jsx
import React, { useState } from 'react';
import useUserStore from '../store/userStore';

const Login = () => {
  const [inputName, setInputName] = useState('');
  // 从仓库中取出 login 方法（仅取需要的方法，性能更好）
  const login = useUserStore(state => state.login);

  // 模拟登录按钮点击
  const handleLogin = () => {
    if (!inputName) return alert('请输入用户名');
    // 调用仓库的 login 方法，更新全局状态
    login('mock-token-123456', inputName);
    alert('登录成功！');
  };

  return (
    <div style={{ padding: 20 }}>
      <input
        placeholder="请输入用户名"
        value={inputName}
        onChange={(e) => setInputName(e.target.value)}
        style={{ marginBottom: 10, padding: 8 }}
      />
      <button onClick={handleLogin} style={{ padding: 8, cursor: 'pointer' }}>
        登录
      </button>
    </div>
  );
};

export default Login;
```

```js
// src/pages/Home.jsx
import React from 'react';
import useUserStore from '../store/userStore';

const Home = () => {
  // 方式 1：批量读取多个状态（推荐，减少重渲染）
  const { isLogin, username, logout } = useUserStore(state => ({
    isLogin: state.isLogin,
    username: state.username,
    logout: state.logout
  }));

  if (!isLogin) {
    return <div>请先 <a href="/login">登录</a></div>;
  }

  return (
    <div style={{ padding: 20 }}>
      <h3>欢迎你，{username}！</h3>
      <button onClick={logout} style={{ padding: 8, cursor: 'pointer' }}>
        退出登录
      </button>
    </div>
  );
};

export default Home;
```
## token持久化
业务逻辑流程
1. 应用启动 → 从localStorage读取token等认证信息
2. 用户登录 → 设置登录状态并保存到localStorage
3. 用户操作 → 状态变更自动持久化
4. 页面刷新 → 从localStorage恢复状态，保持登录状态
5. 用户登出 → 清除localStorage中的认证信息
   
问题: 在对token进行简单的持久化处理后 在首页我将token删除 不会自动跳转到登录页面 需要刷新后才会实现
实现持久化自动监听token 页面刷新时检查token是否存在 如果不存在则跳转到登录页

# 将原型图迁移到了Ai-Healthy项目中
下一步开始编写进入首页后的业务逻辑
首页业务逻辑分析:
  包含信息:
    1. 数据展示: 用户名 日期 用户头像 用户今日可摄入热量 以及各个数据的展示
    2. 导航栏: 包含咨询 分析 我的 三个选项 点击后跳转到对应的页面
      2.1 咨询: 点击后跳转到ai聊天页面
      2.2 分析: 点击后跳转到分析页面 用于上传食物图片 并收集为json 发送给后端 后端交由ai分析 分析后后端转回结果 前端将收集到的结果放置在首页
      2.3 我的: 点击后跳转到我的页面  
        2.3.1 提醒设置: 点击后跳转到提醒设置页面 用于设置提醒时间 以及是否开启提醒
        2.3.2 账号管理: 点击后跳转到账号管理页面 用于修改密码 以及删除账号
后续打算 将原型图逐步替换为antd组件 尽量保持样式不改变
# 开发首屏数据展示
开发思路就是先设计一套遵循restfulapi的mock模拟数据 然后根据这套数据设置api接口 最后在首页中调用api接口获取数据 展示在首页中
## mock接口设计与api接口设计
mock接口这里不做展示
通过封装api接口
```ts
export function getOverview(){
    return get('/dashboard')
}

export function createRecord(data:any){
    return post('/records',data)
}

// 更新今日指定餐次数据
export function updateRecord(type:string,data:any){
    return put(`/records/${type}`,data)
}

```
## 首页数据获取方法
使用useEffect处理数据获取函数 通过loading状态判断是否展示loading状态 以及是否展示数据 当数据加载完成之后就重新设置loading状态 展示页面
方法有点糙 但是能用
```tsx
return (
  <div id="page-home" className="page-container active" style={{ padding: '40px 20px 20px',backgroundColor:'#fafefb' }}>
    {loading?<Spin/>:<div> .....组件内容</div>}
  </div>
)
```
使用map方法快速生成进度条组件 ['carbs', 'protein', 'fat'] as const 常量断言语法 解决字符串索引与具体对象属性的类型不匹配问题 将string类型的item转换为具体的对象属性类型
```tsx
<Col xs={24} sm={14} md={16}>
  <div className="macro-stats">
    {
      (['carbs', 'protein', 'fat'] as const).map((item) => {
        const data = summary?.[item];
        return (
          <div key={item} className="macro-item">
            <Row justify="space-between" style={{ marginBottom: '4px' }}>
              <Text>{macroLabels[item]}</Text>
              <Text type="secondary">{data?.current}/{data?.target}{data?.unit}</Text>
            </Row>
            <Progress
              className="macroProgress"
              // 计算百分比 当前摄入量/总摄入量 * 100
              percent={data ? (data.current / data.target) * 100 : 0}
              showInfo={false}
              strokeColor={item === 'carbs' ? '#fbbf24' : item === 'protein' ? '#60a5fa' : '#10b981'}
              trailColor="#e2e8f0"
              size="small"
            />
          </div>
        )
      })
    }
  </div>
</Col>
```
# 开发首页卡片今日饮食记录的新增与修改,删除功能

在今天的开发完成了首页核心功能——“今日饮食记录”卡片的重构与增删改查（CRUD）逻辑的集成。为了提升用户体验，我们将原本分散在页面顶部的全局操作按钮全部移除，转而采用更加直观的“卡片内联操作”模式。

**1. UI 交互逻辑重构与 RecordCard 组件升级**
我们重新设计了 `RecordCard` 组件，使其具备了三种状态：有数据态、无数据态（空白占位）和只读态。在有数据时，卡片右上角会悬浮显示编辑和删除图标，且删除操作接入了 `Popconfirm` 二次确认弹窗以防误删；当某餐次（早餐、午餐、晚餐）暂无记录时，卡片会显示为一个带有加号按钮的占位容器，引导用户点击新增。此外，通过 `readOnly` 属性，我们让“昨日记录”部分复用了同一套卡片样式，但禁用了所有操作权限，保持了界面的统一性与逻辑的严密性。

**2. 样式优化与内联样式提取**
为了解决图片在卡片中显示不全的问题，我们利用 CSS 的 `object-fit: cover` 属性确保了食物图片能够完美填充容器背景。同时，为了提高代码的可维护性，我们将 `DashBoread/index.tsx` 中大量的内联样式提取到了独立的 `index.scss` 文件中，利用 SCSS 的嵌套语法清晰地管理页面布局、圆环统计区以及卡片网格系统。

**3. 表单状态管理与异步数据同步**
在 `RecordForm` 表单组件的开发中，我们解决了 React 常见的“渲染期间更新状态”的警告。通过 `useEffect` 钩子，我们确保了在 Modal 打开时才将选中的记录数据同步到 Ant Design 的 Form 实例中。在数据提交环节，我们打通了从表单校验、调用 `updateRecord` API 到父组件 `refresh` 刷新列表的完整链路。

**4. 技术细节与错误修复**
针对开发过程中遇到的 TypeScript 类型报错，我们通过 `as const` 断言解决了对象索引访问的类型安全问题。同时，针对 Mock 环境下偶尔出现的网络超时错误，我们将 Axios 的基础配置 `timeout` 从 300ms 提高到了 5000ms，确保了请求的稳定性。此外，我们还修正了代码中如 `todayReacord` 等拼写错误，并优化了数据获取函数，将其封装在 `try-catch-finally` 结构中，确保了 Loading 状态能够正确闭环。
目前，首页饮食记录的“增、删、改、查”功能已全部跑通，页面布局清爽且操作逻辑符合直觉，为后续接入 AI 饮食建议功能打下了坚实的 UI 与数据基础。
这一天的开发涵盖了 React 组件设计、TypeScript 类型体操、Ant Design 深度应用以及异步数据流管理。
### 1. 难点与解决方案 (Challenges & Solutions)
*   **React 渲染周期的状态同步 (`setState` in `useEffect`)**
    *   **问题**：在 `RecordForm` 中，直接在组件函数体内部调用 `form.setFieldsValue` 会导致 "Cannot update a component while rendering a different component" 警告，甚至引发无限循环渲染。
    *   **解决**：将表单数据的回填逻辑包裹在 `useEffect` 中，并依赖 `isModalOpen` 和数据源的变化。这确保了状态更新只在副作用阶段（Render 之后）发生，符合 React 的单向数据流原则。
*   **TypeScript 动态索引签名 (`Index Signature`)**
    *   **问题**：在遍历 `summary` 对象时，使用 `item` (string) 去访问 `summary[item]` 会报错，因为 TypeScript 无法确定字符串变量是否是 `summary` 对象的有效 Key。
    *   **解决**：使用 **Const Assertion** (`as const`)。
    *   **代码**：
        ```typescript
        {/* 之前是 string[]，现在通过 as const 锁定为字面量元组 */}
        {['carbs', 'protein', 'fat'] as const).map(item => (
            // summary[item] 现在是类型安全的
        ))}
        ```
    *   后续我们将这种方式直接封装成数组变量和获取对应数据的辅助函数 来统一处理 让数据更易读,这不仅解决了报错，还为 IDE 提供了更好的自动补全支持。
### 2. 技术重点 (Key Technical Points)
*   **组件的职责分离与复用 (`RecordCard` Design)**
    *   我们设计了一个高度复用的 [recordCard.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/components/dashborad/recordCard.tsx)，它不仅仅是一个展示组件，还通过 `readOnly` 属性和传入的回调函数（`onEdit`, `onDelete`）承载了业务逻辑的入口。
    *   **Empty State Pattern**：在组件内部处理“无数据”状态，显示占位符和新增按钮，而不是在父组件写 `if-else`，这大大简化了父组件 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx) 的 JSX 结构。
### 3. 经验
*   **异步操作的完整闭环 (`Try-Catch-Finally`)**
    *   在 [index.tsx](file:///d:/web-frontend-protect/aiHealthy/Ai-Healthy/src/page/DashBoread/index.tsx#L96-102) 的 `getOverviewData` 中，我们将 `setLoading(false)` 放在 `finally` 块中。这保证了无论请求成功还是失败（甚至是代码报错），Loading 状态都能被正确重置，避免页面“假死”。

# 后续优化方向
在修改完卡片数据后 做到只刷新对应卡片的数据 而不是刷新整个页面

# 接入ai 
## 简单搭建后端服务 
这个服务是异步处理的 本质上是在ai服务供应商的服务器上处理请求 将请求信息转发到前端 也就是一个BWF信息转发层
1. node服务 主要的点是使用openai的api实现与ai服务器的通信 然后将接口转发到前端  openai.chat.completions.create
2.  openai.chat.completions.create函数包含一个对象参数 对象参数中需要两个属性
    * messages: [{ role: "user", content: message }], 包含用户输入的信息
    * model: "deepseek-chat"  使用的模型
```js
import express from 'express'
const app=express()
import OpenAI from "openai";
import cors from 'cors' 

app.use(cors())
app.use(express.json())

const openai = new OpenAI({
        baseURL: 'https://api.deepseek.com',
        apiKey: 'sk-1ab0732077a749b2962dcc8cc1dca7e9',
});
app.post('/api/chat',async (req,res)=>{
    try {
        const {message}=req.body
        console.log('收到消息:', message); // Debug log
        const completion = await openai.chat.completions.create({
            messages: [{ role: "user", content: message }],
            model: "deepseek-chat",
        });
        
        console.log('AI响应:', completion.choices[0].message.content);
        res.json({response:completion.choices[0].message.content})
    } catch (error) {
        console.error('服务器错误详细信息:', error); // 打印完整错误堆栈
        res.status(500).json({ 
            error: '服务器内部错误', 
            details: error.message 
        });
    }
})
app.listen(3000,()=>{
    console.log('server is running on port 3000')
})

```
completion用来接受ai服务器发送回来的响应内容 
```js
const completion = await openai.chat.completions.create({
  messages: [{ role: "user", content: message }],
  model: "deepseek-chat",
});
```
## 搭建简答的前端服务
搭建相当简单 只需要对信息做收集 发送 接受 渲染即可
```html
<body>
    <input type="text" id="message-input" placeholder="请输入消息">
    <button id="send-button">发送</button>
    <div id="chat-container"></div>
</body>
<script>
    const messageInput=document.getElementById('message-input')
    const sendButton=document.getElementById('send-button')
    const chatContainer=document.getElementById('chat-container')
    async function sendMessage(message){
        const response=await fetch('http://localhost:3000/api/chat',{
            method:'POST',
            headers:{
                'Content-Type':'application/json'
            },
            body:JSON.stringify({message})
        })
        const data=await response.json()
        return data.response
    }
    sendButton.addEventListener('click',async ()=>{
        const message=messageInput.value
        if(!message) return
        messageInput.value=''
        const userMessage=document.createElement('div')
        userMessage.textContent=`你:${message}`
        chatContainer.appendChild(userMessage)
        const botMessage=document.createElement('div')
        botMessage.textContent=`助手:${await sendMessage(message)}`
        chatContainer.appendChild(botMessage)
    })
```

## 改造node服务 请求流式响应 发送流式响应 前端渲染流式响应 实现打字机效果
### 1. 后端请求流式响应 并转发
开是要设置响应头: 这是必须要设置的 告诉前端这是一个流式响应 不能缓存 保持连接
```js
res.setHeader('Content-Type','text/event-stream')//流式输出
    res.setHeader('Cache-Control','no-cache')// 禁用缓存
    res.setHeader('Connection','keep-alive')// 保持连接
```
然后模拟ai服务 逐字返回 前端渲染打字机效果:
这里我们必须要注意 每次发送字符给前端 都必须要符合SSE协议格式 否则前端无法正确解析 也就是每次都发送`data: ${JSON.stringify({ content: char })}\n\n` 这是固定写法 而且必须使用res.write 发送 不能使用res.send 否则前端无法正确解析
在响应的最后必须发送`data: [DONE]\n\n` 这是固定写法 否则前端无法正确解析
```js
// 模拟ai逐字逐字返回
let index=0
const timer = setInterval(() => {
if (index < Answer.length) {
  //SSE 协议格式：data: 内容\n\n（必须严格遵守）
  const char = Answer[index];
  // 核心 使用res.write 发送字符给前端
  res.write(`data: ${JSON.stringify({ content: char })}\n\n`);
  index++;
} else {
  // 结束流式传输（发送结束标识）
  clearInterval(timer);
  res.write('data: [DONE]\n\n'); // 自定义结束标识
  res.end(); // 关闭连接
}
}, 100); // 每 100ms 返回一个字符，模拟打字机速度
```
因为我们在响应头设置了保持链接的响应头 所以必须主动去断开链接
```js
// 5. 处理前端断开连接（避免内存泄漏）
res.on('close', () => {
  clearInterval(timer);
  res.end();
});
```
完整代码
```js
sseApp.post('/api/chat',async (req,res)=>{
    // 设置响应头 发送sse 流
    res.setHeader('Content-Type','text/event-stream')//流式输出
    res.setHeader('Cache-Control','no-cache')// 禁用缓存
    res.setHeader('Connection','keep-alive')// 保持连接
    // 从前端获取消息
    const {message}=req.body
    // 发送消息给前端
    const Answer='这是你发送的消息:'+message+'这段消息用来处理学习sse数据的实现一个极简的 Demo：前端输入文字 → 后端模拟 AI 逐字返回（打字机效果）→ 前端实时展示，不涉及 AI 真实接口，只聚焦 SSE 流式处理本身'
    // 模拟ai逐字逐字返回
    let index=0
    const timer = setInterval(() => {
    if (index < Answer.length) {
      //SSE 协议格式：data: 内容\n\n（必须严格遵守）
      const char = Answer[index];
      // 核心 使用res.write 发送字符给前端
      res.write(`data: ${JSON.stringify({ content: char })}\n\n`);
      index++;
    } else {
      // 结束流式传输（发送结束标识）
      clearInterval(timer);
      res.write('data: [DONE]\n\n'); // 自定义结束标识
      res.end(); // 关闭连接
    }
  }, 100); // 每 100ms 返回一个字符，模拟打字机速度

  // 5. 处理前端断开连接（避免内存泄漏）
  res.on('close', () => {
    clearInterval(timer);
    res.end();
  });
})
```
### 2. 前端渲染流式响应 实现打字机效果
1. 发送请求
在发送请求是必须带上响应头: 否则前端不能解析后端传来的数据
```js
'Content-Type':'application/json'
```
2. 处理后端数据 实现打字机效果
  1. 首先使用`response.body.getReader()` 方法获取到一个`ReadableStreamDefaultReader` 对象 这个对象可以用来读取流式响应的数据 就是创建一个读取器 这个读取器允许我们手动、逐块读取流式响应中的数据
   ```js
    const reader = response.body.getReader();
   ```
  2. 创建一个解码器 用来将获取的二进制字符转换为字符数据 这里我们使用`TextDecoder` 这个类 来创建一个解码器 这个解码器可以将二进制数据转换为字符串 注意因为流式处理每次只能传递一个字符 我们需要使用循环来读取所有字符
   ```js
    const decoder = new TextDecoder(); 
     while (true) {
      //....
  }
   ```
  3. 使用读取器中的read方法 将获取的数据逐块读取 并使用解码器将二进制数据转换为字符串 value是二进制数据表示当前读取的字符 done表示是否读取完成
   ```js
    const { done, value } = await reader.read();
    console.log('done:',done);   // 布尔值
    console.log('value:',value); //二进制数据
    if (done) break;
   ```
  4. 使用解码器将获取的value数据转化为字符串  chunk:" data: {"content":"身"}\n\n '空' " 这是我们转化得到的数据 使用\n\n来分割分割后的数据 lines:['data: {"content":"身"}', '']是一个数组
   ```js
    const chunk = decoder.decode(value); // 解析后是一个字符串 " data: {"content":"身"}\n\n '空' "
    console.log('chunk:',chunk);
    // SSE 数据可能一次包含多个消息，按 \n\n 分割
    const lines = chunk.split('\n\n');
    console.log('lines:',lines);// 分割后是一个数组 ['data: {"content":"身"}\n\n', '']
    ```
  5. 遍历lines数组 对每个元素进行处理 去掉前缀'data: '和分割后多余的空字符串'' 得到最终的数据 {"content":"身"}  注意w3c规范流式输出结束后需要传递[data: [DONE]] 我们需要判断是否是结束标识 如果是结束标识 则直接跳出循环 否则继续处理
  6. 将得到的数据转化为json数据  const json = JSON.parse(dataStr);  aiAnswer.textContent += json.content;最后渲染到前端
  ```js
  for (const line of lines) {
          if (line.startsWith('data: ')) {
              const dataStr = line.replace('data: ', '').trim(); // 去掉前缀 'data: '和分割后多余的空字符串''
              console.log('dataStr:',dataStr); // {"content":"身"} 得到的数据
              if (dataStr === '[DONE]') { //根据协议标准 到响应的最后阶段会传递结束符 chunk: data: [DONE]
                  console.log('流传输结束');
                  break;
              }
              try {
                  // 必带：解析 JSON 字符串 原本 {"content":"身"}--> {content:'身'}
                  const json = JSON.parse(dataStr); 
                  console.log('json:',json);
                  // 实时追加内容
                  aiAnswer.textContent += json.content;
              } catch (e) {
                  console.error('解析 JSON 失败:', e, dataStr);
              }
          }
      }
  ```
完整代码
```js
sendBtn.addEventListener('click',async ()=>{
  const message=inputMsg.value
  if(!message) return
  inputMsg.value=''
  aiAnswer.textContent='' // 清空之前的回答        
  const response=await fetch('http://localhost:3000/api/chat',{
      method:'POST',
      headers:{
          // 必带：告诉后端请求体是 JSON 格式（否则后端 req.body 为 undefined）
          'Content-Type':'application/json'
      },
      body:JSON.stringify({message})
  })

  // 核心：处理流式响应
  const reader = response.body.getReader();
  console.log('reader:',reader);
  // 必带：创建文本解码器，将二进制数据转换为字符串
  const decoder = new TextDecoder(); 
  while (true) {
      console.log('读取数据');
      // done: 表示流是否结束 value: 表示读取到的二进制数据
      const { done, value } = await reader.read();
      console.log('done:',done);   // 布尔值
      console.log('value:',value); //二进制数据
      if (done) break;
      // 解码二进制数据
      const chunk = decoder.decode(value); // 解析后是一个字符串 " data: {"content":"身"}\n\n '空' "
      console.log('chunk:',chunk);
      // SSE 数据可能一次包含多个消息，按 \n\n 分割
      const lines = chunk.split('\n\n');
      console.log('lines:',lines);// 分割后是一个数组 ['data: {"content":"身"}\n\n', '']
      
      for (const line of lines) {
          if (line.startsWith('data: ')) {
              const dataStr = line.replace('data: ', '').trim(); // 去掉前缀 'data: '和分割后多余的空字符串''
              console.log('dataStr:',dataStr); // {"content":"身"} 得到的数据
              if (dataStr === '[DONE]') { //根据协议标准 到响应的最后阶段会传递结束符 chunk: data: [DONE]
                  console.log('流传输结束');
                  break;
              }
              try {
                  // 必带：解析 JSON 字符串 原本 {"content":"身"}--> {content:'身'}
                  const json = JSON.parse(dataStr); 
                  console.log('json:',json);
                  // 实时追加内容
                  aiAnswer.textContent += json.content;
              } catch (e) {
                  console.error('解析 JSON 失败:', e, dataStr);
              }
          }
      }
  }
})
```
### 使用真实api接口处理流式响应
前端部分不变 只需要修改后内容
基本上内容大差不差 不会变 处理流式响应只需要在openai.chat.completions.create()中添加stream: true, // 开启流式输出
然后使用异步遍历(异步迭代器)的方法将请求来的数据逐块读取 并按SSE协议格式推送给前端
```js
// 设置响应头 发送sse 流
  res.setHeader('Content-Type','text/event-stream')//流式输出
  res.setHeader('Cache-Control','no-cache')// 禁用缓存
  res.setHeader('Connection','keep-alive')// 保持连接
  // 从前端获取消息
  const {message}=req.body
  // 发送消息给前端
  const stream = await openai.chat.completions.create({
    messages: [
      { role: "system", content: "You are a helpful assistant." }, // 系统提示词
      { role: "user", content: message } // 用户提问
    ],
    model: "deepseek-chat",
    stream: true, // 开启流式输出
    temperature: 0.7, // 可选：调整回答随机性
  });

  // 3. 逐块读取流式数据（异步迭代器）
  for await (const chunk of stream) {
    // 3.1 提取单块内容（注意：chunk 可能为空，需过滤）
    const content = chunk.choices[0]?.delta?.content || '';
    if (content) {
      // 3.2 按 SSE 协议格式推送给前端（\n\n 结尾）
      res.write(`data: ${JSON.stringify({ content })}\n\n`);
    }
  }
// 5. 处理前端断开连接（避免内存泄漏）
res.on('close', () => {
  clearInterval(timer);
  res.end();
});
```

# 在项目中接入ai 
我们使用antdx组件库 npm install @ant-design/x --save 来快速开发对应的样式
处理流式数据与ai api工具集 我们使用aiSDK npm install @ant-design/x-sdk --save
## 使用AISDK
这里我们分为前端和后端 同属一库但是代码分开管理
* 前端：负责展示聊天界面、处理用户输入、展示 AI 回复（打字机效果）、卡片编辑功能。
npm i @ai-sdk/deepseek @ai-sdk/react @tanstack/react-router ai
使用方法:
useChat钩子是aiSdk提供的hook 是整个ai交互的核心钩子 中间的配置是自定义的 api后面跟着的是自己后端的地址 因为我们用的不是全栈框架 不能直接在前端项目文件夹中直接写后端服务 所以这里我们使用express提供后端服务 然后通过vite的代理配置将原本的express后端地址代理为api 所以后续项目中的后端地址就直接写成api了 
```js
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': 'http://localhost:3002',
    },
  },
})
```
```js
const { messages, sendMessage, status, error, clearError } = useChat({
  api: '/api/chat',
});
```
其中messages用于来在前端渲染出对话消息 其中messages是一个数组 其每个元素都是一个对象 包含了role:角色信息 parts储存对话信息的数据 parts数组中的每个元素都是一个对象 其中包含了type信息 记录ai返回的信息类型 比如text文本信息 json数据等等 part.text 直接返回ai传回的文本信息
```js 渲染对话列表
{messages.map(message => (
  <div key={message.id} className="whitespace-pre-wrap">
    {message.role === 'user' ? 'User: ' : 'AI: '}
    {message.parts.map((part, i) => {
      switch (part.type) {
        case 'text':
          return <div key={`${message.id}-${i}`}>{part.text}</div>;
      }
    })}
  </div>
))}
```
sendMessage是一个发送请求的函数,我们可以直接使用受控组件input获取用户输入的消息 然后通过sendMessage向接口发送post请求
```js
onSubmit={e => {
  e.preventDefault();
  if (!input.trim()) return;
  if (status === 'streaming' || status === 'submitted') return;
  sendMessage({ text: input });
  setInput('');
}}
```
我这里的前端代码是直接套用的aisdk中的模版 只是在服务器代理上稍作修改 所以不过多赘述
* 后端 ：负责接收前端发送的消息、调用 AI 模型生成回复、将回复流式返回给前端。
后端所需要执行的命令和配置如下:npm i @ai-sdk/deepseek ai cors dotenv
使用方法: 在初始化完后端项目之后我们开发对应chat页面的路由 不过aisdk官网中提供的也仅仅只有那些全栈框架的后端服务 所以我们在使用express创建服务的时候需要稍作改变

首先使用express创建路由 然后使用aisdk提供的库 创建deepseek提供的实例 并配置好apiKey
```js
import { createDeepseekChat } from '@ai-sdk/deepseek';

const deepseekChat = createDeepseekChat({
  apiKey: process.env.DEEPSEEK_API_KEY,
});
```
然后开始开发对应的业务逻辑,不过这里的大多数业务逻辑 比如设置请求头 发送流式响应等等aisdk都已经封装好了 我们直接调用即可
先跑断当前配置的api是否启用 然后从req请求体中将用户发送的messages取到 然后使用库中streamText方法 在参数中配置模型模型和传入messages 将结果使用pipeUIMessageStreamToResponse方法将结果流式返回给前端即可 后续还会拓展很多东西 比如让ai规范输出的提示词 和functioncall功能和sehamc规范返回数据等等
其中tool是ai可以调用的工具 system是系统提示词
```js
Router.post('/', async (req, res) => {
  try {
    if (!process.env.AI_GATEWAY_API_KEY) {
      return res.status(500).json({ error: '缺少环境变量 AI_GATEWAY_API_KEY' });
    }

    const { messages } = req.body;

    const result = streamText({
      model: deepseek('deepseek-chat'),
      messages: convertToModelMessages(messages),
      system: '你是一位专业的营养减肥专家。请用简单易懂、通俗的语言回答用户关于营养和减肥的问题。回答要言简意赅，避免长篇大论，重点突出实用建议。',
      tools: {
        mealInfoAnalysis: tool({
          description: 'Analyze the user\'s meal information and provide nutritional advice',
          inputSchema: z.object({
            mealInfo: z
              .string()
              .describe('The user\'s meal information'),
          }),
          execute: async () => {
            const todayMeal=await MealItem.findAll({
                where:{
                    userId:uid,
                    date: date
                }
            })
            return {
              todayMeal,
            };
          },
        })
      },
    });

    result.pipeUIMessageStreamToResponse(res);
  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});
```
# 使用antdX美化界面
在antdX中提供了丰富的组件 我们可以直接使用这些组件来美化我们的界面 比如聊天页的消息气泡 发送按钮 输入框等等 我们可以直接使用这些组件来美化我们的界面 具体的使用方法可以参考antdX的官方文档
这里我们使用antdx中的Sender组件发送框 Bubble气泡组件

```jsx
message.parts.map((part, i) => {
switch (part.type) {
  case 'text':
  return <Bubble
      placement={message.role === 'user' ? "end" : 'start'}
      key={message.id}
      content={part.text}
      typing={{ effect: 'fade-in' }}
      header={message.role === 'user'?<h5>{nickname}</h5>:<h5>健康助手</h5>}
      footer={(content) => (
        <Actions items={actionItems(content)} onClick={() => console.log(content)} />
      )}
      avatar={<Avatar icon={<AntDesignOutlined />} />}
    />
}
<Sender
  loading={loading}
  value={input}
  onChange={(value)=>{
    setInput(value)
  }}
  onCancel={() => {
    setLoading(false);
  }}
  placeholder='请输入你想问的问题'
  onSubmit={() => {
    if (!input.trim()) return;
    if (status === 'streaming' || status === 'submitted') return;
    setLoading(true);
    sendMessage({ text: input });
    setInput('');
  }}
  autoSize={{ minRows: 1, maxRows: 6 }}
>
</Sender>
```
# 实现ai对话持久化
如果不做消息持久化我们和ai对话完刷新页面就会造成聊天记录的消失,实现数据持久化需要我们创建一个数据库
1. 使用docker命令创建数据库
在server中创建docker-compose.yml文件 配置mysql数据库
  services:
  mysql:
    image: mysql:8.3.0
    command:
      --default-authentication-plugin=mysql_native_password
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
    environment:
      - MYSQL_ROOT_PASSWORD=admin123
      - MYSQL_LOWER_CASE_TABLE_NAMES=0
    ports:
      - "3306:3306"
    volumes:
      - ./data/mysql:/var/lib/mysql
1. 安装sequelize 配置数据库 操作数据库
npm i -g sequelize-cli 安装sequelize-cli 用于操作数据库
npm i mysql2
初始化项目 sequelize init
配置config 填入用户的密码和数据库端口
1. 创建模型与迁移文件: npx sequelize-cli model:generate --name ChatHistory --attributes sessionId:string,role:string,content:text
```js
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('ChatHistories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      sessionId: {
        allowNull: false,
        type: Sequelize.STRING
      },
      role: {
        allowNull: false,
        type: Sequelize.STRING
      },
      content: {
        allowNull: false,
        type: Sequelize.TEXT
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('ChatHistories');
  }
};
```
2. 创建数据库（如果不存在） npx sequelize-cli db:create
3. 执行迁移（建表） npx sequelize-cli db:migrate
4. 生成种子文件（准备测试数据） npx sequelize-cli seed:generate --name demo-chat-history
5. 运行种子（填充数据） npx sequelize-cli db:seed --seed demo-chat-history
```js
async up (queryInterface, Sequelize) {
    await queryInterface.bulkInsert('ChatHistories', [
      {
        sessionId: 'session-001',
        role: 'user',
        content: '你好，你是谁？',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        sessionId: 'session-001',
        role: 'assistant',
        content: '你好！我是你的 AI 营养顾问，有什么可以帮你的吗？',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        sessionId: 'session-002',
        role: 'user',
        content: '苹果有什么营养？',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ], {});
  },
```
执行 sequelize db:seed 运行种子文件

将自动生成的迁移文件和种子文件的后缀从 .js 改为 .cjs  因为nodejs默认是commonjs模块规范 而sequelize-cli默认是esm模块规范
然后在router路由中我们引入chatHistory模型 然后在路由中使用chatHistory模型操作数据库
我们的需求是用户进入聊天页面之后 自动返回今天当天的聊天记录 我们可以根据createAt查询出今天的聊天记录
后续使用有一些困难,因为我开始使用的是esm的引入方法导致了很多难以解决的问题 所以以后开发尽量使用cjs或者esm中的一种准则
因为使用真实接口会被mock拦截 所以我们只能暂时放弃mock 选择后端与前端一同开发了 目前先开发ai聊天页面 然后开发首页的接口与数据库相关

 
## 将数据库中的数据拉去到本地 然后让前端渲染
用户的话：存放在 content 文件夹里。
AI 的话：存放在 parts 文件夹里。
后端:
1. get请求 向前端发送信息 其中Op用来设置查询条件的 ChatHistory作为查询主体模型表示数据库 
``` js 查询从今天开始的所有聊天记录
const chatHistories = await ChatHistory.findAll({
    where: {
        createdAt: {
          // 查询条件:今日
          [Op.gte]: new Date(new Date().setHours(0, 0, 0, 0)),
        },
      },
    });
```
将查询到的记录规范一下数据格式去除不必要的数据
这里必须强调一下: 前端接受ai的返回的消息一定需要role content 和parts这三种数据结构的 如果缺少其中一个都会导致渲染失败或请求失败
你的话：存放在 content 文件夹里。
AI 的话：存放在 parts 文件夹里。
```js
const formattedHistories = chatHistories.map(h => ({
  role: h.role,
  content: h.content,
  // 前端渲染数据库中的数据必须包含parts
  parts: [{ type: 'text', text: h.content }]
}));
```
最后返回一下信息即可
```js
import { Op } from 'sequelize';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const { ChatHistory } = require('../models/index.cjs');
dotenv.config();
const Router = express.Router();
const deepseek = createDeepSeek({
  apiKey: process.env.AI_GATEWAY_API_KEY,
});
Router.get('/',async(req,res)=>{
  try{
    const chatHistories = await ChatHistory.findAll({
    where: {
        createdAt: {
          // 查询条件:今日
          [Op.gte]: new Date(new Date().setHours(0, 0, 0, 0)),
        },
      },
    });
    const formattedHistories = chatHistories.map(h => ({
      role: h.role,
      content: h.content,
      // 前端渲染数据库中的数据必须包含parts
      parts: [{ type: 'text', text: h.content }]
    }));

    res.status(200).json({
        status:true,
        message:'获取聊天记录成功',
        data: formattedHistories // 直接返回数组
    })
  }catch(error){
    console.error('获取聊天记录失败:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
})
```
2. post请求发送ai接口 因为我们已经存在获取立即聊天记录的情况了
先获取用户传递来的messages const { messages } = req.body; 注意 这里的messages其实存储的是整个上下文对话 为什么 因为我们不管是从数据库获取信息还是前端直接发送信息 都设置了setmessaegs 我们将所以信息都保存在了setMessage中了 所以在前端调用这些方法的时候本质上都是在增加上下文对话

过滤有效信息系:
前端发来的消息通常带有 id , createdAt , parts 等字段，如果直接传给模型，模型会因为“看不懂”这些额外字段而报错,后端向ai服务器发送的数据只能包含content role两种信息 因为向后端发送后 会自动生成parts 返回给前端渲染 后端接受信息本质上只接受role content两个信息!!! 但是千万要记住不能把parts完全丢弃 每次对话完成后的messages,看下面分析就明白了 其实ai和用户侧发送的数据都不包含content 但是content又是前端渲染和后端发送请求必须有的数据 所以我们必须手动把parts中的数据都放到content中 这样才能保证服务的完整性
```js
/* 对话
{  用户侧输入内容
  id: "d34JmCPQtZHoktYG",
  metadata:undefined,
  parts:[
    {type: 'text', text: '1'}e: 'done'}
  ],
  role: "user",
},
{  ai侧回复内容
  id:"FRi895ssu4WmWf8A",
  metadata:undefined,
  parts:[
    {type: 'step-start'},
    {type: 'text', text: '你好！看起来你输入了“1”。请问你是想了解某个营养相关的话题，还是有具体的问题需要咨询呢？比如：\n\n… 健康食谱推荐  \n- 其他营养疑问  \n\n请告诉我更多细节，我会为你提供有针对性的帮助哦！ 🌟', providerMetadata: undefined, state: 'done'}
  ],
  role: "assistant"
}
*/
// 使用该函数洗刷数据 将数据合法化
const modelMessages = messages.map((msg) => {
const role = msg?.role;
// 兼容处理：用户消息有 content，AI 消息（parts）需要提取 text
let content = typeof msg?.content === 'string' ? msg.content : '';

// 如果用户输入不存在 就将content设置为parts中的内容 这一点很重要 这意味着ai具备了完整的上下文记忆
// 因为用户输入通常是一个字符串 而parts是一个数组 所以需要将parts中的文本合并起来 
if (!content && Array.isArray(msg?.parts)) {
  content = msg.parts
    .filter((part) => part && part.type === 'text')
    .map((part) => part.text)
    .join('');
}

if (!content) {
  return null;
}
return { role, content };
}).filter(Boolean);
```

最后发送数据即可 完整代码如下:
```js
const { messages } = req.body;
if (!Array.isArray(messages)) {
  return res.status(400).json({ error: 'messages 必须是一个数组' });
}

const modelMessages = messages.map((msg) => {
    const role = msg?.role;
    // 兼容处理：用户消息有 content，AI 消息（parts）需要提取 text
    let content = typeof msg?.content === 'string' ? msg.content : '';
    
    // 如果用户输入不存在 就将content设置为parts中的内容 这一点很重要 这意味着ai具备了完整的上下文记忆
    // 因为用户输入通常是一个字符串 而parts是一个数组 所以需要将parts中的文本合并起来 
    if (!content && Array.isArray(msg?.parts)) {
      content = msg.parts
        .filter((part) => part && part.type === 'text')
        .map((part) => part.text)
        .join('');
    }

    if (!content) {
      return null;
    }
    return { role, content };
  }).filter(Boolean);
if (modelMessages.length === 0) {
  return res.status(400).json({ error: 'messages 内容为空或格式不正确' });
}
const result = streamText({
  model: deepseek('deepseek-chat'),
  messages: modelMessages,
  // messages: messages,
});
result.pipeUIMessageStreamToResponse(res);
```
## 本地对话数据发送到数据库
在发送请的时候将我们的对话上传到数据库汇总 然后在ai回复完成后将ai返回的数据上传到数据库中
只需要在原本的post请求上添加两个改动点就行 当我们处理完modelmessages之后我们直接取出最新的数据存到数据库中 然后在ai返回结束之后触发onFinish函数 将ai返回的数据也存到数据库中即可 注意onFinish函数定义在streamText中 作为结果即可
```js
// 获取筛查后的最后一条信息并存到数据库中
const lastMessage=modelMessages[modelMessages.length-1]
if(lastMessage){
  await ChatHistory.create({
    sessionId: 'session-001',
    role: lastMessage.role,
    content: lastMessage.content,
  })
}else{
  console.log('最后一条信息为空')
}
const result = streamText({
  model: deepseek('deepseek-chat'),
  messages: modelMessages,
  // 2. 当 AI 回复完成后，保存 AI 的回复内容
  onFinish: async (event) => { 
    try {
      await ChatHistory.create({
        sessionId: 'session-default',
        role: 'assistant',
        content: event.text // event.text 是 AI 回复的完整字符串
      });
      console.log('AI 回复已保存到数据库');
    } catch (dbError) {
      console.error('保存 AI 回复失败:', dbError);
    }
  }
});
```
# 使用AISDK配置AI functioncall 实现可编辑卡片
AI 减肥助手的饮食分析功能：用户在聊天页输入饮食信息（如 “早餐吃 2 个鸡蛋”），AI 解析出食物名称 / 热量 / 数量 / 单位等结构化数据，前端将数据渲染为可编辑卡片，用户修改卡片内容后，点击确认能同步更新首页的饮食数据；同时前端聊天页需区分 AI 返回的自然语言回复和卡片结构化数据，分别对应不同渲染逻辑。
整体遵循 **「前端提交 - 后端 AI 解析 - 流式返回 - 前端解析 - 分类型渲染 - 编辑同步」** 流程，核心围绕结构化数据获取和多类型数据区分处理展开，分前后端核心逻辑：
1. 后端核心（保证 AI 返回标准结构化数据，流式传给前端）
基于支持 Function Call 的 AI 模型，配置自定义 Tool 并定义严格 Schema，强制 AI 按规则返回包含餐型 / 食物列表 / 总热量的 JSON（无此能力则用Output.json()+JSON 校验兜底）；
对 AI 返回数据做二次校验，补全缺失字段、修正类型错误，封装type 类型标识（text/card/error）；
通过SSE 流式传输将带标识的分段数据返回前端，避免页面阻塞。
1. 前端核心（解析流式数据，分类型渲染，实现编辑同步）
用SSE JSON 解析工具类拼接分段数据，校验并解析出完整的带标识数据；
根据type标识分类型渲染：text渲染普通聊天气泡，card渲染可编辑饮食卡片，error渲染错误提示；
卡片绑定编辑事件，实时计算总热量，用户确认修改后，将新数据提交后端更新；
通过全局状态管理同步修改后的数据，让首页自动刷新，保证数据一致性。
1. 核心关键
全程通过type 类型标识解决 “前端区分自然语言 / 卡片数据” 的核心问题，通过AI Tool/Function Call解决 “AI 解析数据不规范（字段缺失 / 类型错误）” 的核心痛点，通过SSE + 解析工具类解决 “流式分段 JSON 无法直接解析” 的问题。
# 开发数据库,登录,聊天页路由 后端
数据结构:
summary: {
  carbs: { current: 50, target: 120, unit: 'g' },
  protein: { current: 70, target: 100, unit: 'g' },
  fat: { current: 25, target: 40, unit: 'g' },
  calories: { current: 900, target: 2000, unit: 'kcal' },
  totalIntake: 1200
},
开发步骤:
开发数据库 建立用户表 建立饮食数据总数据表 建立三餐数据表
不同数据库的数据格式:
先确定数据格式 然后使用命令建表 修改迁移文件 然后设置关联模型
1.用户表{
  id:String, //用户id 主键 自动递增
  username:string, //用户名 邮箱或手机号
  password:String, //用户密码 加密存储
  email:String,//用户邮箱 可作为用户名 可选
  tel:String, //用户手机号 可作为用户名 可选
  nickName:String, //用户昵称 必填
  role:Number, //用户角色 0:普通用户 1:管理员  默认0
  createTime:Date, //用户创建时间  默认当前时间
}
npx sequelize-cli model:generate --name User --attributes username:string,password:string,email:string,tel:string,nickName:string,role:integer
2.饮食数据总数据表{
  userId:String, //用户id 必填
  date:DATEONLY, //日期 必填
  currentCarbs:Number, //当前摄入碳水化合物 必填 如果不填默认为0
  currentProtein:Number, //当前摄入蛋白质 必填 如果不填默认为0
  currentFat:Number, //当前摄入脂肪 必填 如果不填默认为0
  currentCalories:Number, //当前摄入热量  必填 如果不填默认为2000
  targetCarbs:Number, //目标碳水化合物  必填 如果不填默认为120
  targetProtein:Number, //目标蛋白质  必填 如果不填默认为100
  targetFat:Number, //目标脂肪  必填 如果不填默认为40
  targetCalories:Number, //目标热量  必填 如果不填默认为2000
}
npx sequelize-cli model:generate --name Record --attributes userId:integer,date:dateonly,currentCarbs:integer,currentProtein:integer,currentFat:integer,currentCalories:integer,targetCarbs:integer,targetProtein:integer,targetFat:integer,targetCalories:integer
3.三餐数据表{
  userId:String, //用户id 必填
  date:Date, //日期 必填
  mealType:String, //餐型 必填
  foodName:String, //食物名称 必填
  calories:Number, //热量 必填 如果不填默认为0
  imgUrl:String, //食物图片 可选
}
npx sequelize-cli model:generate --name MealItem --attributes userId:integer,date:dateonly,mealType:string,foodName:string,calories:integer,imgUrl:string
各表的模型及其迁移文件均为ai所写 所以不做多展示 因为我也不太会写数据库的东西 所以先交给ai处理
因为添加了user表 所以我们需要修改chat路由 避免多个用户访问同一组聊天记录
修改聊天路由 增加userId参数 用于区分不同用户的聊天记录 并且在数据库中建立userId字段 用于关联用户
注意sendMessage函数中如果想在请求体中添加userId参数 只需要在必要出添加userID的判断就好
sendMessage({ text: input }, { body: { userId } });
```js chat.TSX
// ...
  const userId = useAuthStore((state:any)=>state.userId)|| sessionStorage.getItem('userId')
  // ...
  useEffect(() => {
    async function fetchHistory() {
      try {
        if (!userId) {
          message.error('缺少用户信息，请重新登录');
          return;
        }
        const res = await getChatHistory({userId});
        // res.data.data 现在直接就是我们后端转换后的数组
        if (res.data.data) {
          setMessages(res.data.data);
        }
      } catch (error) {
        message.error('获取历史记录失败');
        console.error(error);
      }
    }
    fetchHistory();
  }, [setMessages, userId]);
  //..
  onSubmit={() => {
          if (!input.trim()) return;
          if (!userId) {
            message.error('缺少用户信息，请重新登录');
            return;
          }
          if (status === 'streaming' || status === 'submitted') return;
          setLoading(true);
          sendMessage({ text: input }, { body: { userId } });
          setInput('');
        }}
  //...
```
后端修改 这两个路由上都添加判断userID的方法
```js server/router/chat
Router.get('/',async(req,res)=>{
  try{
    const userId = req.query.userId;
    if (!userId) {
      return res.status(400).json({ error: '缺少 userId 参数' });
    }
    const uid = parseInt(userId, 10);
    if (isNaN(uid)) {
      return res.status(400).json({ error: 'userId 必须是数字' });
    }

    const chatHistories = await ChatHistory.findAll({
    where: {
        userId: uid,
        createdAt: {
          [Op.gte]: new Date(new Date().setHours(0, 0, 0, 0)),
        },
      },
    });
    //.........
  }
  })

// 写法基本上不变 只需要在必要出添加判断即可
Router.post('/', async (req, res) => {
  try {
    if (!process.env.AI_GATEWAY_API_KEY) {
      return res.status(500).json({ error: '缺少环境变量 AI_GATEWAY_API_KEY' });
    }
    const { messages, userId } = req.body;
    if (!userId) {
      return res.status(400).json({ error: '缺少 userId 参数' });
    }
    const uid = parseInt(userId, 10);
    if (isNaN(uid)) {
      return res.status(400).json({ error: 'userId 必须是数字' });
    }
    if (!Array.isArray(messages)) {
      return res.status(400).json({ error: 'messages 必须是一个数组' });
    }
    const modelMessages = messages.map((msg) => {
        const role = msg?.role;
        let content = typeof msg?.content === 'string' ? msg.content : '';
        if (!content && Array.isArray(msg?.parts)) {
          content = msg.parts
            .filter((part) => part && part.type === 'text')
            .map((part) => part.text)
            .join('');
        }
        if (!content) {
          return null;
        }
        return { role, content };
      }).filter(Boolean);
    if (modelMessages.length === 0) {
      return res.status(400).json({ error: 'messages 内容为空或格式不正确' });
    }
    // 获取筛查后的最后一条信息并存到数据库中
    const lastMessage=modelMessages[modelMessages.length-1]
    if(lastMessage){
      await ChatHistory.create({
        sessionId: 'session-001',
        userId: uid,
        role: lastMessage.role,
        content: lastMessage.content,
      })
    }else{
      console.log('最后一条信息为空')
    }
    const result = streamText({
      model: deepseek('deepseek-chat'),
      messages: modelMessages,
      // 2. 当 AI 回复完成后，保存 AI 的回复内容
      onFinish: async (event) => {
        try {
          await ChatHistory.create({
            sessionId: 'session-default',
            userId: uid,
            role: 'assistant',
            content: event.text // event.text 是 AI 回复的完整字符串
          });
          console.log('AI 回复已保存到数据库');
        } catch (dbError) {
          console.error('保存 AI 回复失败:', dbError);
        }
      }
    });
    result.pipeUIMessageStreamToResponse(res);
  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});
```
## 开发登录路由 不包括注册账号 注册功能后续才会加入
从参数中获取当前登录的用户名和密码
在数据库中查找邮箱,电话,用户名 只要对上其一说明用户存在
然后从数据库中获取用户信息 后面就是判断密码是否正确 使用的是bcrypt.compare的方法 比较用户输入的密码和数据库中的密码是否一致 进行下一步返回token 和用户信息 但是在我们的应用里面我们正确的密码有部分是加密的 有部分是未加密的 所以这里我们做了一个比对 如果未加密就直接比对 然后把密码重新加密更新数据库中的老密码
jwt验证呢我们是使用jsonwebtoken库 来发送token和验证token是否有效
```js
Router.post('/sign_in',async function(req,res){
    try{
        const {username,password}=req.body
        if(!username){
            throw new Error('用户名不能为空')
        }
        if(!password){
            throw new Error('密码不能为空')
        }
        //查询数据库中是否有该用户
        const condition={
            where:{
                // or方法同时查找两个字段
                [Op.or]:[
                    {email:username},
                    {tel:username},
                    {username:username}
                ]
            }
        }
        const user=await User.findOne(condition)
        // 如果没有找到就报错
        if(!user){
            throw new Error('该用户不存在')
        }
        const storedPassword = user.password || '';
        const looksHashed = storedPassword.startsWith('$2');
        let isPasswordValid = false;
        if (looksHashed) {
            isPasswordValid = bcrypt.compareSync(password, storedPassword);
        } else {
            isPasswordValid = password === storedPassword;
            if (isPasswordValid) {
                const hashedPassword = bcrypt.hashSync(password, 10);
                await user.update({ password: hashedPassword });
            }
        }
        if (!isPasswordValid) {
            throw new Error('密码不正确')
        }

        const token = jwt.sign({
            userId:user.id
        },process.env.SECRET,{expiresIn:'30d'})
        res.status(200).json({
            status:true,
            message:'登录成功',
            data:{
                token,
                userId: user.id,
                nickName: user.nickName
            }
        })
    }catch(error){
        console.log('登录失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
```
# 开发首页后端路由 
## 开发首页数据展示路由
这里我们对首页的营养面板暂时不做开发 因为我觉得营养面板应该是是ai通过分析用户今日记录 然后根据用户的记录 推荐用户需要补充的营养 这个功能比较复杂暂时不开发 然后先在前端用假数据代替
数据到格式就是我们之前在mock上模拟的数据
然后其实从数据库查询到的数据格式非常乱所以我们使用一个函数来规格饭数据格式
```
[{
  "id": 4,                        // 记录唯一 ID (主键)
  "userId": 3,                    // 所属用户 ID
  "date": "2026-01-24",           // 日期 (YYYY-MM-DD)
  "mealType": "Breakfast",        // 餐食类型 (枚举: Breakfast, Lunch, Dinner, Snack)
  "foodName": "Oatmeal",          // 食物名称 (对应前端需要的 name)
  "calories": 350,                // 卡路里数值
  "imgUrl": "https://...",        // 图片链接 (对应前端需要的 img)
  "createdAt": "2026-01-25...",   // 创建时间
  "updatedAt": "2026-01-25..."    // 更新时间
}]
```
规范数据格式: 使用getMeal来获取某一餐的数据 某一餐的数据包含三个小项
```js
const formatMeals = (meals) => {
  const getMeal = (type) => {
      const meal = meals.find(m => m.mealType && m.mealType.toLowerCase() === type);
      return meal ? {
          name: meal.foodName || '',
          calories: meal.calories || 0,
          img: meal.imgUrl || ''
      } : { name: '', calories: 0, img: '' };
  };
  return {
      breakfast: getMeal('breakfast'),
      lunch: getMeal('lunch'),
      dinner: getMeal('dinner')
  };
}
```
```js
Router.get('/:userId',async(req,res)=>{
    try{
        const userId=req.params.userId
        const today = new Date().toISOString().split('T')[0]
        const yesterdayDate = new Date()
        yesterdayDate.setDate(yesterdayDate.getDate() - 1)
        const yesterday = yesterdayDate.toISOString().split('T')[0]
        const todayMeal=await MealItem.findAll({
            where:{
                userId:userId,
                date: today
            }
        })
        
        const yesterdayMeal=await MealItem.findAll({
            where:{
                userId:userId,
                date: yesterday
            }
        })

        const formatMeals = (meals) => {
            const getMeal = (type) => {
                const meal = meals.find(m => m.mealType && m.mealType.toLowerCase() === type);
                return meal ? {
                    name: meal.foodName || '',
                    calories: meal.calories || 0,
                    img: meal.imgUrl || ''
                } : { name: '', calories: 0, img: '' };
            };
            return {
                breakfast: getMeal('breakfast'),
                lunch: getMeal('lunch'),
                dinner: getMeal('dinner')
            };
        };

        const data={
            // 死数据 模拟数据
            summary:{
                carbs: { current: 50, target: 120, unit: 'g' },
                protein: { current: 70, target: 100, unit: 'g' },
                fat: { current: 25, target: 40, unit: 'g' },
                calories: { current: 900, target: 2000, unit: 'kcal' },
                totalIntake: 1200
            },
            todayRecord:{
                date:today,
                meals: formatMeals(todayMeal)
            },
            yesterdayRecord:{
                date:yesterday,
                meals: formatMeals(yesterdayMeal)
            }
        }
        return res.status(200).json({
            status:true,
            message:'查询成功',
            data
        })
    }catch(error){
        console.log('查询记录失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
```
## 开发数据更新路由,新增数据路由
值得注意的是当我们更新数据或新增数据时 我们都需要判断该条记录是否存在 然后还需要将mealtype转化为大写 因为在前端里面我们将mealtype定义为了小写 但在数据库中我们将其定义为了大写 所以必须在前端或后端中将其一修改 但是前端修改成本很大 所以我们在后端将其转化为大写
```js
Router.put('/:userId',async(req,res)=>{
    try{
        const userId=req.params.userId
        const {foodName,calories,mealType}=req.body
        if(!userId){
            return res.status(400).json({
                status:false,
                message:'用户ID不能为空'
            })
        }
        if(!foodName){
            return res.status(400).json({
                status:false,
                message:'食物名称不能为空'
            })
        }
        if(!calories){
            return res.status(400).json({
                status:false,
                message:'卡路里不能为空'
            })
        }
        if(!mealType){
            return res.status(400).json({
                status:false,
                message:' mealType不能为空'
            })
        }
        const normalizedMealType=normalizeMealType(mealType)
        const condition={
            userId,
            date: new Date().toISOString().split('T')[0],
            mealType:normalizedMealType
        }
        await MealItem.update({
            foodName,
            calories,
            mealType:normalizedMealType
        },{
            where:condition
        })
        return res.status(200).json({
            status:true,
            message:'更新成功'
        })
    }catch(error){
        console.log('更新失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})

Router.delete('/:userId',async(req,res)=>{
    try{
        const userId=req.params.userId
        const mealType = req.body.mealType || req.query.mealType
        if(!userId){
            return res.status(400).json({
                status:false,
                message:'用户ID不能为空'
            })
        }
        const normalizedMealType=normalizeMealType(mealType)
        if(!normalizedMealType){
            return res.status(400).json({
                status:false,
                message:'mealType不能为空'
            })
        }
        const condition={
            userId,
            date: new Date().toISOString().split('T')[0],
            mealType:normalizedMealType
        }
        await MealItem.destroy({
            where:condition
        })
        return res.status(200).json({
            status:true,
            message:'删除成功'
        })
    }catch(error){
        console.log('删除失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
Router.post("/:userId",async(req,res)=>{
        try{
        const userId=req.params.userId
        const {foodName,calories,mealType}=req.body
        if(!userId){
            return res.status(400).json({
                status:false,
                message:'用户ID不能为空'
            })
        }
        if(!foodName){
            return res.status(400).json({
                status:false,
                message:'食物名称不能为空'
            })
        }
        if(!calories){
            return res.status(400).json({
                status:false,
                message:'卡路里不能为空'
            })
        }
        if(!mealType){
            return res.status(400).json({
                status:false,
                message:' mealType不能为空'
            })
        }
        const normalizedMealType=normalizeMealType(mealType)
        const condition={
            userId,
            date: new Date().toISOString().split('T')[0],
            mealType:normalizedMealType
        }
        const existingItem=await MealItem.findOne({
            where:condition
        })
        if(existingItem){
            return res.status(400).json({
                status:false,
                message:'该餐次已存在'
            })
        }
        await MealItem.create({
            foodName,
            calories,
            mealType:normalizedMealType,
            userId:userId,
            date:new Date().toISOString().split('T')[0]
        })
        return res.status(200).json({
            status:true,
            message:'添加成功'
        })
    }catch(error){
        console.log('添加失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
```
# 开发分析页面 前端
1. 各部分功能分佢: 我们把该页面分为功能区与数据区 功能区包括上传图片 识别信息表格 确定添加按钮 数据展示区包括今日热量摄取量 今日三餐详细数据展示
- 顶部日历
```html
<Card className="analysis-top-card">
  <Row justify="space-between" align="middle" gutter={[16, 16]}>
      <div className="date-picker-wrapper">
        <DatePicker
          allowClear={false}
          value={currentDate}
          onChange={(value) => {
            if(!value){
              return
            }
            setCurrentDate(value)
            reLoadData(value.format('YYYY-MM-DD'))
          }}
          suffixIcon={null}
          style={{ border: 'none', background: 'transparent', width: 120, textAlign: 'center' }}
          inputReadOnly
        />
      </div>
  </Row>
</Card>
```
- 数据展示区 其中数据展示区域的每日餐食卡片我们封装为了一个组件RecordCard 组件中包含了该餐次的食物名称 卡路里 摄入来源 图片等信息
```js
<Col xs={24} lg={14}>
<Card
  bordered={false}
  className="analysis-card hover-card"
  title={
    <Space>
      <Avatar style={{ backgroundColor: '#e6f7ff', color: '#1890ff' }} icon={<PieChartOutlined />} />
      <span style={{ fontSize: 18, fontWeight: 600 }}>当日饮食记录</span>
    </Space>
  }
  extra={
    <Space>
      <Text type="secondary">目标: {targetCalories}</Text>
      <Tag color={caloriePercent > 100 ? 'red' : 'green'}>{caloriePercent}%</Tag>
    </Space>
  }
>
  {/* 该日总摄入量 */}
  <div style={{ marginBottom: 24, padding: '16px', background: '#f5f5f5', borderRadius: 8 }}>
    <Row align="middle" gutter={24}>
      <Col span={18}>
        <Text type="secondary" style={{ display: 'block', marginBottom: 8 }}>今日摄入热量</Text>
        <Progress
          percent={caloriePercent}
          strokeColor={{ '0%': '#108ee9', '100%': '#87d068' }}
          status="active"
          format={() => <span style={{ color: '#1890ff' }}>{currentCalories} kcal</span>}
        />
      </Col>
      <Col span={6} style={{ textAlign: 'center', borderLeft: '1px solid #d9d9d9' }}>
        <Statistic title="剩余额度" value={targetCalories - currentCalories} suffix="kcal"/>
      </Col>
    </Row>
  </div>
  {/* 该日每餐记录 */}
  <div className="analysis-meals">
    {mealData.map((group) => (
      <RecordCard key={group.mealType} group={group} />
    ))}
  </div>
</Card>
</Col>
```
- 功能区 使用了antd组件库的upload组件上传图片 然后将图片发送给后端 后端将图片发送给ai ai识别后按照规定格式返回
```tsx
<Col xs={24} lg={10}>
<Card
bordered={false}
className="analysis-card hover-card"
title={
  <Space>
    <Avatar style={{ backgroundColor: '#f6ffed', color: '#52c41a' }} icon={<CameraOutlined />} />
    <Text style={{ fontSize: 18, fontWeight: 600 }}>AI 智能识别</Text>
  </Space>
}
>
<Dragger {...uploadProps} style={{ marginBottom: 24, padding: 32, background: '#fafafa', border: '2px dashed #d9d9d9', borderRadius: 12 }}>
  <p className="ant-upload-drag-icon">
    <InboxOutlined style={{ color: '#13ec5b', fontSize: 48 }} />
  </p>
  <p className="ant-upload-text">点击或拖拽上传饮食照片,上传后立即识别</p>
  <p className="ant-upload-hint">支持 JPG、PNG 格式，识别更精准</p>
</Dragger>
<div style={{ marginBottom: 24 }}>
  <Row gutter={16}>
    <Col span={24}>
      <Select
        value={mealType}
        onChange={setMealType}
        style={{ width: '100%', height: 30}}
        size="large"
        placeholder="选择餐次"
      >
        <Option value="Breakfast">早餐</Option>
        <Option value="Lunch">午餐</Option>
        <Option value="Dinner">晚餐</Option>
      </Select>
    </Col>
  </Row>
</div>

{/* Draft Results */}
<Card
  size="small"
  title={`识别结果 (${draftData.length})`}
  extra={"识别不准确可重新识别"}
  style={{ background: '#f9f9f9', borderRadius: 8 }}
>
  <Table
    size="small"
    rowKey="key"
    columns={draftColumns}
    dataSource={draftData}
    pagination={false}
    rowSelection={rowSelection}
    style={{ marginBottom: 16 }}
  />
  <Space direction="vertical" style={{ width: '100%' }}>
    <Button
      type="primary"
      block
      onClick={handleConfirmAdd}
      disabled={!isToday}
      style={{ height: 40, borderRadius: 20 ,backgroundColor:'#13ec5b'}}
    >
      确认添加到 {mealType}
    </Button>
    <Button block danger onClick={handleClearDraft} disabled={!draftData.length} style={{ borderRadius: 20,backgroundColor:'#ff4d4f' }}>
      清空结果
    </Button>
  </Space>
</Card>
</Card>
</Col>
```
1. 各个函数的实现:
- 辅助函数,用于数据格式化
```js
  function formatMeals(data:any){
    const formatDate:MealGroup[]=data.map((item:any)=>{
      return {
        mealType:item.mealType ,
        title: item.mealType,
        currentCalories:item.calories,
        foodName: item.foodName,
        calories: item.calories,
        source:"AI 识别" ,
        imgUrl: item.imgUrl,
      }
    })
    return formatDate
  }
```
- 请求函数,用来向后端请求数据并发送数据
```js
/**
   * 获取当日三餐数据
   */
  async function reLoadData(dateStr?: string){
    const currentDateStr = dateStr || currentDate.format('YYYY-MM-DD');
    try{
      // 获取三餐数据 并更新状态 
      const res=await getMealData(userId!,currentDateStr)
      const formattedMeals = formatMeals(res.data.data || [])
      setMealdata(formattedMeals)

      const nextCurrentCalories = formattedMeals.reduce((acc,item)=>acc+item.currentCalories,0);
      setCurrentCalories(nextCurrentCalories);
      setCaloriePercent(Math.floor(nextCurrentCalories/targetCalories*100));
    }catch(err){
      message.error('发生错误,请求数据失败')
      console.log(err);
      setMealdata([]);
      setCurrentCalories(0);
      setCaloriePercent(0);
    }
  }
  /**
   * 确定添加/更新当前一餐数据
   */
  async function handleConfirmAdd(){
    // 确定后将获取的数据整合 然后发送给后端
    let thisFoodName:string=''
    let thisCalories:number=0;
    // 使用set数据结构保证每个记录只会出现一次
    const selectedKeySet = new Set(selectedRowKeys);
    const selectedItems = draftData.filter((item) => selectedKeySet.has(String(item.key)));
    if (selectedItems.length === 0) {
      message.warning('请先选择要添加的食物');
      return;
    }
    selectedItems.forEach((item, index)=>{
      thisFoodName += item.foodName + (index < selectedItems.length - 1 ? '+' : '');
      thisCalories += item.calories;
    })
    //改用some方法来查询是否存在同餐次
    const exists = mealData.some((item) => item.mealType === mealType);
    try{
      if(exists){
        const res=await updateRecord(userId!,{foodName:thisFoodName,calories:thisCalories,mealType:mealType,imgUrl:imgUrl})
        if(!res){
          console.log('请求失败请重新请求');
        }
      }else{
        const res=await createRecord(userId!,{foodName:thisFoodName,calories:thisCalories,mealType:mealType,imgUrl:imgUrl})
        if(!res){
          console.log('请求失败请重新请求');  
        }
      }
    }catch(err){
      message.error('更新失败');
      console.log(err);
    }finally{
      // 清空图片url
      setImgUrl('');
      reLoadData(currentDate.format('YYYY-MM-DD'))
    }
  }
  /**
   * 清空当前草稿数据
   */
  function handleClearDraft(){
    setDraftData([]);
    setSelectedRowKeys([]);
    setImgUrl('');
  };
```
- 上传图片配置:主要是配置图片的上传流程,包括但不限于配置文件名 设置上传参数 发送上传请求
```js
 const uploadProps: UploadProps = {
    name: 'file',
    multiple: false,
    maxCount: 1,
    showUploadList: true,
    accept: 'image/*',
    async customRequest({ file, onSuccess, onError }) {
      const formData = new FormData();
      formData.append('file', file as any);
      try {
        const res = await uploadImage(formData);
        if (res.data.status) {
          // 获取识别结果 识别结果中包含识别到的食物和卡路里 后端返回的结果中返回了上传的url
          const items = Array.isArray(res.data?.data?.items) ? res.data.data.items : [];
          // 获取用于识别的图片地址
          setImgUrl(res.data.data.url || '')
          const nextDraftData: AIDraftItem[] = items.map((it: any, idx: number) => ({
            key: String(idx + 1),
            foodName: String(it?.foodName || '未知'),
            calories: Number.isFinite(it?.calories) ? Math.trunc(it.calories) : parseInt(String(it?.calories || 0), 10) || 0,
          }));
          setDraftData(nextDraftData);
          setSelectedRowKeys(nextDraftData.map((d) => d.key));
          message.success('识别成功');
          onSuccess?.(res.data);
          return;
        }
        message.error(res.data.message || '识别失败');
        onError?.(new Error(res.data.message));
      } catch (err: any) {
        message.error('识别过程中发生错误');
        onError?.(err);
      }
    }
  };
```
## 后端
设计了四个路由 分别为控制上传图片 控制获取三餐记录 增加记录 更新记录 其中上传图片的路由中配置了qwen3-vl-flash模型 用于识别图中食物与估算卡路里
1. 上传图片路由 :处理流程 现将获取的图片文件存储到临时目录 然后调用qwen3-vl-flash模型 识别图片中的食物与卡路里 最后将识别结果返回给前端 但是图片是临时存储到服务器磁盘的 后续会优化掉这一机制 转而使用阿里云提供的oss 对图片进行存储 并返回图片的url 后续直接将三餐的url存储到服务器即可
先对磁盘存储图片与模型进行配置,这里我们用到了path模块与multer插件和openai提供的sdk
```js
const uploadDir = path.join(__dirname, '../public', 'uploads');// 拼接上传文件保存目录：server/public/uploads
// 递归创建目录（若不存在）
fs.mkdirSync(uploadDir, { recursive: true });
// 配置 multer 磁盘存储规则
const storage = multer.diskStorage({
    // 文件保存路径
    destination: function (req, file, cb) {
        cb(null, uploadDir);
    },
    // 生成唯一文件名：字段名-时间戳-随机数.原扩展名
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});
const upload = multer({ storage });
// 初始化视觉模型
const openai=new OpenAI({
    apiKey: process.env.AI_VISION_API_KEY,
    baseURL: "https://dashscope.aliyuncs.com/compatible-mode/v1"
})
```
```js
Router.post('/upload', upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ status: false, message: '未上传文件' });
        }
        // 构建文件访问 URL
        const fileUrl = `/uploads/${req.file.filename}`;
        // 读取文件内容
        const fileBuffer = await fs.promises.readFile(req.file.path);
        // 确定 MIME 类型
        const mimeType = req.file.mimetype || 'image/jpeg';
        // 转换为 base64 编码 可以提供给ai读取
        const imageDataUrl = `data:${mimeType};base64,${fileBuffer.toString('base64')}`;

        const response = await openai.chat.completions.create({
            model: "qwen-vl-max",
            messages: [
                {
                    role: "system",
                    content: "你是一个食物识别助手。你必须输出 JSON(大小写不敏感)并且只输出 JSON,不要输出任何解释、Markdown、代码块、换行前后的多余文本。输出必须严格符合以下结构(字段名必须一致):{ \"items\": [{\"key\":\"1\",\"foodName\":\"香煎三文鱼\",\"calories\":280}] } 规则：1) items 必须是数组，表示图片中识别出的多种食物，按重要程度排序；2) key 必须是字符串且在 items 内唯一（\"1\",\"2\",...）；3) foodName 必须是中文字符串；4) calories 必须是整数(kcal)，不要带单位；5) 如果完全无法判断食物，则返回 {\"items\":[{\"key\":\"1\",\"foodName\":\"未知\",\"calories\":0}]}；6) 不允许输出除 items 之外的额外字段，不允许输出 null。"
                },
                {
                    role: "user",
                    content: [
                        { type: "image_url", image_url: { url: imageDataUrl } },
                        { type: "text", text: "请根据图片识别食物列表并估算每项热量，只输出 JSON。" }
                    ]
                }
            ],
            response_format: { type: 'json_object' }
        });
        // 解析ai返回的json数据
        const content = response?.choices?.[0]?.message?.content;
        const json = typeof content === 'string' ? JSON.parse(content) : content;
        // 从json中提取items数组 并处理空数组情况
        const rawItems = Array.isArray(json?.items) ? json.items : [];
        // 对items数组进行映射处理 处理空值情况
        const items = rawItems.map((item, idx) => {
            const key = String(idx + 1);
            const foodName = item?.foodName
            const calories = Number(item?.calories)
            return { key, foodName, calories };
        });
        // 处理空数组情况 确保items至少包含一个元素
        const safeItems = items.length ? items : [{ key: '1', foodName: '未知', calories: 0,img:'' }];
        return res.status(200).json({
            status:true,
            message:'识别成功',
            data:{
                // 上传的图片url
                url: fileUrl,
                items: safeItems
            }
        })
    } catch (error) {
        return res.status(500).json({ status: false, message: error.message });
    }
});
```
- 新增 修改 查询 三个路由基本上和首页路由是一模一样的 只是多了一个用户上传的日期参数 不会默认返回今日和昨日的参数了 数据格式的约束也没有放在后端 而是直接交给前端处理
```js
Router.post('/dashborad/:userId',async(req,res)=>{
    try{
        const userId=req.params.userId
        const date=req.body.currentDate || new Date().toISOString().split('T')[0]
        const todayMeal=await MealItem.findAll({
            where:{
                userId:userId,
                date: date
            }
        })
        
        const data=todayMeal
        return res.status(200).json({
            status:true,
            message:'查询成功',
            data
        })
    }catch(error){
        console.log('查询记录失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
Router.put('/:userId',async(req,res)=>{
    try{
        const userId=req.params.userId
        const {foodName,calories,mealType,imgUrl}=req.body
        if(!userId){
            return res.status(400).json({
                status:false,
                message:'用户ID不能为空'
            })
        }
        if(!foodName){
            return res.status(400).json({
                status:false,
                message:'食物名称不能为空'
            })
        }
        if(!calories){
            return res.status(400).json({
                status:false,
                message:'卡路里不能为空'
            })
        }
        if(!mealType){
            return res.status(400).json({
                status:false,
                message:' mealType不能为空'
            })
        }
        const normalizedMealType=normalizeMealType(mealType)
        const condition={
            userId,
            date: new Date().toISOString().split('T')[0],
            mealType:normalizedMealType
        }
        await MealItem.update({
            foodName,
            calories,
            mealType:normalizedMealType,
            imgUrl
        },{
            where:condition
        })
        return res.status(200).json({
            status:true,
            message:'更新成功'
        })
    }catch(error){
        console.log('更新失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
Router.post("/:userId",async(req,res)=>{
        try{
        const userId=req.params.userId
        const {foodName,calories,mealType,imgUrl}=req.body
        if(!userId){
            return res.status(400).json({
                status:false,
                message:'用户ID不能为空'
            })
        }
        if(!foodName){
            return res.status(400).json({
                status:false,
                message:'食物名称不能为空'
            })
        }
        if(!calories){
            return res.status(400).json({
                status:false,
                message:'卡路里不能为空'
            })
        }
        if(!mealType){
            return res.status(400).json({
                status:false,
                message:' mealType不能为空'
            })
        }
        const normalizedMealType=normalizeMealType(mealType)
        const condition={
            userId,
            date: new Date().toISOString().split('T')[0],
            mealType:normalizedMealType
        }
        const existingItem=await MealItem.findOne({
            where:condition
        })
        if(existingItem){
            return res.status(400).json({
                status:false,
                message:'该餐次已存在'
            })
        }
        await MealItem.create({
            foodName,
            calories,
            mealType:normalizedMealType,
            userId:userId,
            date:new Date().toISOString().split('T')[0],
            imgUrl
        })
        return res.status(200).json({
            status:true,
            message:'添加成功'
        })
    }catch(error){
        console.log('添加失败',error.message)
        res.status(400).json({
            status:false,
            message:error.message
        })
    }
})
```
## 图片上传与AI分析返回数据
### 上传图片
multer 是 Express 里最常用的“文件上传中间件”，专门用来处理浏览器上传的 multipart/form-data 请求（比如上传图片、视频、附件）
前端: 我们使用的是antd的图片上传组件
这是组件的配置 引入组件后就需要在配置中配置上传后执行的逻辑 以及上传时的规则
- customRequest ：自定义上传（你要自己发请求）
- beforeUpload ：上传前校验/拦截
- onChange ：文件状态变化时触发（uploading/done/error 等）
- onRemove ：删除文件时触发
以上字段是不同函数的执行时机与函数名称 这都是规定好的 如果随意填写就压根不会触发
1.创建文件对象FormData() 然后把上传的文件添加进去 记住参数一定是我们在配置定义时写的name
2.向后端发送post请求 记得配置好请求头标注发送的文件类型
```ts
// 上传图片
export function uploadImage(formData: FormData) {
  return http.post('/api/analysis/upload', formData,{
    headers: { 'Content-Type': 'multipart/form-data' } // 声明文件上传格式
  })
}
```
```js
const uploadProps: UploadProps = {
  name: 'file',
  multiple: false,//一次只能上传一张
  showUploadList: true,
  accept: 'image/*',
  // 自定义上传逻辑：将图片文件上传至服务器
  async customRequest({ file, onSuccess, onError }) {
    const formData = new FormData();
    formData.append('file', file);
    try {
      const res = await uploadImage(formData);
      if (res.data.status) {
        message.success('图片上传成功');
        // 这里可以保存返回的 url 到状态中，以便后续提交表单使用
        console.log('Uploaded file URL:', res.data.url);
        onSuccess?.(res.data);
      } else {
        message.error(res.data.message || '上传失败');
        onError?.(new Error(res.data.message));
      }
    } catch (err: any) {
      message.error('上传过程中发生错误');
      onError?.(err);
    }
  }
};
```
后端:
在开发接口之前我们需要提前引入处理文件的插件(因为这里我们还没有配置ai 所以我们零食将文件放置在文件夹中) 处理multer存储的插件 这个插件就是将图片存储到磁盘的插件
```js
const uploadDir = path.join(process.cwd(), 'public', 'uploads');
// 递归创建目录（若不存在）
fs.mkdirSync(uploadDir, { recursive: true });
// 配置 multer 磁盘存储规则
const storage = multer.diskStorage({
    // 文件保存路径
    destination: function (req, file, cb) {
        cb(null, uploadDir);
    },
    // 生成唯一文件名：字段名-时间戳-随机数.原扩展名
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});
const upload = multer({ storage });
const Router = express.Router();
Router.post('/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ status: false, message: '未上传文件' });
        }
        //临时将图片存储到文件夹中 后续会直接发送给ai
        const fileUrl = `/uploads/${req.file.filename}`;
        return res.status(200).json({
            status: true,
            message: '上传成功',
            url: fileUrl
        });
    } catch (error) {
        return res.status(500).json({ status: false, message: error.message });
    }
});
```
### 转发给ai接受消息
这里我们用到的是qwen3-vl-flash 用于处理视觉识别的内容 然后将识别结果返回给前端 使用到的sdk是openai npm i openai
先看实例:
```js
import OpenAI from "openai";

const openai = new OpenAI(
    {
        // 若没有配置环境变量，请用百炼API Key将下行替换为：apiKey: "sk-xxx",
        apiKey: process.env.DASHSCOPE_API_KEY,
        baseURL: "https://dashscope.aliyuncs.com/compatible-mode/v1"
    }
);
async function main() {
    const response = await openai.chat.completions.create({
        model: "qwen3-vl-flash", // 此处以qwen-vl-max为例，可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models
        messages: [{role: "user",content: [
            { type: "image_url",image_url: {"url": "https://dashscope.oss-cn-beijing.aliyuncs.com/images/dog_and_girl.jpeg"}},
            { type: "text", text: "这是什么？" },
        ]}]
    });
    console.log(JSON.stringify(response));
}

main();
```
先接入试一下
基本上可以 然后就是规范一下提示词的问题,基本流程就是先获取本地图片 然后将图拍转成base64的格式 然后提交给ai 等ai返回json 然后再规范一下json写法
```js
// 构建文件访问 URL
const fileUrl = `/uploads/${req.file.filename}`;
// 读取文件内容
const fileBuffer = await fs.promises.readFile(req.file.path);
// 确定 MIME 类型
const mimeType = req.file.mimetype || 'image/jpeg';
// 转换为 base64 编码 可以提供给ai读取
const imageDataUrl = `data:${mimeType};base64,${fileBuffer.toString('base64')}`;

const response = await openai.chat.completions.create({
    model: "qwen-vl-max",
    messages: [
        {
            role: "system",
            content: "你是一个食物识别助手。你必须输出 JSON(大小写不敏感)并且只输出 JSON,不要输出任何解释、Markdown、代码块、换行前后的多余文本。输出必须严格符合以下结构(字段名必须一致):{ \"items\": [{\"key\":\"1\",\"foodName\":\"香煎三文鱼\",\"calories\":280}] } 规则：1) items 必须是数组，表示图片中识别出的多种食物，按重要程度排序；2) key 必须是字符串且在 items 内唯一（\"1\",\"2\",...）；3) foodName 必须是中文字符串；4) calories 必须是整数(kcal)，不要带单位；5) 如果完全无法判断食物，则返回 {\"items\":[{\"key\":\"1\",\"foodName\":\"未知\",\"calories\":0}]}；6) 不允许输出除 items 之外的额外字段，不允许输出 null。"
        },
        {
            role: "user",
            content: [
                { type: "image_url", image_url: { url: imageDataUrl } },
                { type: "text", text: "请根据图片识别食物列表并估算每项热量，只输出 JSON。" }
            ]
        }
    ],
    response_format: { type: 'json_object' }
});
// 解析ai返回的json数据
const content = response?.choices?.[0]?.message?.content;
const json = typeof content === 'string' ? JSON.parse(content) : content;
// 从json中提取items数组 并处理空数组情况
const rawItems = Array.isArray(json?.items) ? json.items : [];
// 对items数组进行映射处理 处理空值情况
const items = rawItems.map((item, idx) => {
    const key = String(idx + 1);
    const foodName = item?.foodName
    const calories = Number(item?.calories)
    return { key, foodName, calories };
});
// 处理空数组情况 确保items至少包含一个元素
const safeItems = items.length ? items : [{ key: '1', foodName: '未知', calories: 0,img:'' }];
return res.status(200).json({
    status:true,
    message:'识别成功',
    data:{
        // 上传的图片url
        url: fileUrl,
        items: safeItems
    }
})
```
由于我们上传的都是本地文件 所以转地址很烦 后期使用oss代替本地地址后就可以正常存取图片了

# 个人中心页面开发
记录必备的个人信息 包括 用户账号管理页面 个人健康信息管理页面(身高,体重,年龄,性别) 因为这个网站主要是提供每日饮食记录与分析的 重点不应该放在减肥上 应该是健康饮食管理 所以web主要提供健康饮食分析 健康饮食记录 每日饮食热量管理 这些功能 个人页面主要就记录个人的基本信息与身体状况描述(个人基本信息和身体状况描述会在填写后上传到个人信息表中,后续会根据表中内容提供对应服务) 后续可以将这些信息发送给ai ai会分析当前的健康状况 返回每日推荐的热量需求 首页应该展示每日饮食推荐(将用户的个人信息上传给ai 然后每日第一次进入网站的时候会上传用户的个人身体状况给ai ai返回今日的三餐推荐.如果不是第一次会将进入判断 判断个人信息表中update是否是今日,如果是就不上传请求) 今日热量摄入
个人信息管理表: 用户id 身高 体重 年龄 性别 身体状况描述 
然后是用户信息管理页面 可以修改用户名 邮箱 密码 头像等信息 
然后是退出登录按钮

设计用户健康信息表单 后端
{
  userID:number,
  height:number,
  weight:number,
  age:number,
  sex:number,
  bodyStatus:string,
}
npx sequelize-cli model:generate --name HealthyInfo --attributes userID:integer,height:integer,weight:integer,age:integer,sex:integer,bodyStatus:string,
数据库建表
# 企业级表单请求规范
1. 用户体验:需要一个loading状态 用来表示请求是否进行
2. 使用trycatch做完整的异常处理考虑所有可能的异常
3. 优化用户交互体验 比如请求失败不会自动关闭弹窗等 
